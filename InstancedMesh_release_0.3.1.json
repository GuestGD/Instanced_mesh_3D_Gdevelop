{
  "author": "",
  "category": "General",
  "extensionNamespace": "",
  "fullName": "Instanced Mesh",
  "helpPath": "https://github.com/GuestGD",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyMy4wLjMsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iSWNvbnMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgMzIgMzIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDMyIDMyOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+DQo8Zz4NCgk8cGF0aCBkPSJNNi42LDE5LjhjLTAuMywwLTAuNS0wLjEtMC43LTAuM2wtMy43LTMuN2MtMC4yLTAuMi0wLjMtMC40LTAuMy0wLjdzMC4xLTAuNSwwLjMtMC43bDEuNS0xLjVjMC4zLTAuMywwLjctMC40LDEtMC4yDQoJCWwwLjgsMC4zbDAuNi0wLjZjLTAuMS0xLDAuMi0yLjEsMS0yLjlsNC4yLTQuMmMxLjctMS43LDQtMi43LDYuNS0yLjhsMC40LDBjMC40LDAsMC44LDAuMiwwLjksMC42czAuMSwwLjgtMC4yLDEuMWwtMC41LDAuNQ0KCQljLTEuMywxLjMtMiwzLjEtMS43LDQuOWMwLDAuMy0wLjEsMC42LTAuMywwLjhsLTQuMiw0LjJjLTAuOCwwLjgtMS44LDEuMS0yLjksMWwtMC42LDAuNkw5LDE3YzAuMSwwLjQsMCwwLjctMC4yLDFsLTEuNSwxLjUNCgkJQzcuMSwxOS43LDYuOSwxOS44LDYuNiwxOS44eiIvPg0KPC9nPg0KPHBhdGggZD0iTTI4LjgsMjIuNEwxNy42LDEyLjFsLTMuOSwzLjljLTAuMSwwLjEtMC4xLDAuMS0wLjIsMC4ybDEwLjQsMTEuM2MwLjcsMC43LDEuNSwxLjEsMi41LDEuMWMwLDAsMC4xLDAsMC4xLDANCgljMC45LDAsMS44LTAuNCwyLjUtMWMwLjctMC43LDEtMS42LDEtMi42QzI5LjksMjQsMjkuNSwyMy4xLDI4LjgsMjIuNHoiLz4NCjwvc3ZnPg0K",
  "name": "InstancedMeshRelease",
  "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/Glyphster Pack/Master/SVG/Construction/1d961fe14868858d30e5f3fb6ef216fc609ec4ba0ae1571bab4b10a4e0b45ff1_Construction_hammer_tool.svg",
  "shortDescription": "Create 3D instanced mesh ",
  "version": "0.2",
  "description": "Create 3D instanced mesh (read Three JS docs for more info)",
  "tags": [
    "3d mesh optimization perfomance"
  ],
  "authorIds": [
    "W0yoMQqOeiULIwY1i1Qd8tprOyD2"
  ],
  "dependencies": [],
  "eventsFunctions": [
    {
      "description": "Define helper classes JavaScript code.",
      "fullName": "Define helper classes JavaScript code.",
      "functionType": "Action",
      "name": "DefineHelperClasses",
      "private": true,
      "sentence": "Define helper classes JavaScript code.",
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "VarGlobalTxt"
              },
              "parameters": [
                "_customThreeObject_type",
                "=",
                "\"box\""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (gdjs.__box3DExtension) {",
                "    return;",
                "}",
                "",
                "class Box3DRenderer {",
                "    /** @type {gdjs.CustomRuntimeObject} */",
                "    object;",
                "    /** @type {THREE.InstancedMesh} */",
                "    instancedMesh;",
                "",
                "    /**",
                "     * @param {gdjs.CustomRuntimeObject} object - The custom runtime object.",
                "     * @param {number} width - Width of the cube instances.",
                "     * @param {number} height - Height of the cube instances.",
                "     * @param {number} depth - Depth of the cube instances.",
                "     * @param {number} instanceCount - Number of instances to render.",
                "     * @param {number} offsetX - Offset between instances on the X axis.",
                "     * @param {number} offsetY - Offset between instances on the Y axis.",
                "     * @param {number} offsetZ - Offset between instances on the Z axis.",
                "     * @param {number} horizCountMax - Max instances in the horizontal (Y) line.",
                "     * @param {number} vertCountMax - Max instances in the vertical (Z) lines before moving along the X axis.",
                "     * @param {number} widthSegments - Number of segments for the width of the box.",
                "     * @param {number} heightSegments - Number of segments for the height of the box.",
                "     * @param {number} depthSegments - Number of segments for the depth of the box.",
                "     */",
                "    constructor(object, width, height, depth, instanceCount, offsetX, offsetY, offsetZ, maxYCount, maxZCount, widthSegments, heightSegments, depthSegments) {",
                "        this.object = object;",
                "",
                "        // Use the widthSegments, heightSegments, and depthSegments parameters when constructing the BoxGeometry.",
                "        const geometry = new THREE.BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments);",
                "        const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });",
                "        this.instancedMesh = new THREE.InstancedMesh(geometry, material, instanceCount);",
                "        this.instancedMesh.name = object.name || \"InstancedMeshBox\";",
                "",
                "        this.layoutInstances(width, height, depth, instanceCount, offsetX, offsetY, offsetZ, maxYCount, maxZCount);",
                "",
                "        object.get3DRendererObject().add(this.instancedMesh);",
                "    }",
                "",
                "    layoutInstances(width, height, depth, instanceCount, offsetX, offsetY, offsetZ, maxYCount, maxZCount) {",
                "        let x = 0, y = 0, z = 0;",
                "        let yCount = 0, zCount = 0;",
                "",
                "        for (let i = 0; i < instanceCount; i++) {",
                "            const matrix = new THREE.Matrix4();",
                "            const position = new THREE.Vector3(x, y, z);",
                "            const quaternion = new THREE.Quaternion(); // No rotation",
                "            const scale = new THREE.Vector3(1, 1, 1); // Default scale",
                "",
                "            matrix.compose(position, quaternion, scale);",
                "            this.instancedMesh.setMatrixAt(i, matrix);",
                "",
                "            if (++yCount >= maxYCount) {",
                "                yCount = 0;",
                "                y = 0;",
                "                z += depth + offsetZ; // Move up along the Z axis for a new vertical layer.",
                "",
                "                if (++zCount >= maxZCount) {",
                "                    zCount = 0;",
                "                    z = 0; // Reset Z position",
                "                    x += width + offsetX; // Move along the X axis for a new line",
                "                }",
                "            } else {",
                "                y += width + offsetY; // Move along the Y axis within the same layer",
                "            }",
                "",
                "            this.instancedMesh.instanceMatrix.needsUpdate = true;",
                "        }",
                "    }",
                "}",
                "",
                "// Expose the Box3DRenderer to be available as part of the box3DExtension.",
                "gdjs.__box3DExtension = {",
                "    Box3DRenderer",
                "};",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ]
        },
        {
          "folded": true,
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "VarGlobalTxt"
              },
              "parameters": [
                "_customThreeObject_type",
                "=",
                "\"sphere\""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (gdjs.__sphere3DExtension) {",
                "    return;",
                "}",
                "",
                "class Sphere3DRenderer {",
                "    /** @type {gdjs.CustomRuntimeObject} */",
                "    object;",
                "    /** @type {THREE.InstancedMesh} */",
                "    instancedMesh;",
                "",
                "    /**",
                "     * @param {gdjs.CustomRuntimeObject} object - The custom runtime object.",
                "     * @param {number} radius - Radius of the sphere instances.",
                "     * @param {number} widthSegments - Number of segments horizontally (longitude).",
                "     * @param {number} heightSegments - Number of segments vertically (latitude).",
                "     * @param {number} phiStart - Horizontal starting angle.",
                "     * @param {number} phiLength - Horizontal sweep angle size.",
                "     * @param {number} thetaStart - Vertical starting angle.",
                "     * @param {number} thetaLength - Vertical sweep angle size.",
                "     * @param {number} instanceCount - Number of instances to render.",
                "     * @param {number} offsetX - Offset between instances on the X axis.",
                "     * @param {number} offsetY - Offset between instances on the Y axis.",
                "     * @param {number} offsetZ - Offset between instances on the Z axis.",
                "     * @param {number} horizCountMax - Max instances in the horizontal (Y) line.",
                "     * @param {number} vertCountMax - Max instances in the vertical (Z) lines before moving along the X axis.",
                "     */",
                "    constructor(object, radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength, instanceCount, offsetX, offsetY, offsetZ, maxYCount, maxZCount) {",
                "        this.object = object;",
                "",
                "        const geometry = new THREE.SphereGeometry(",
                "            radius,",
                "            widthSegments,",
                "            heightSegments,",
                "            phiStart,",
                "            phiLength,",
                "            thetaStart,",
                "            thetaLength",
                "        );",
                "        const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });",
                "        this.instancedMesh = new THREE.InstancedMesh(geometry, material, instanceCount);",
                "        this.instancedMesh.name = object.name || \"InstancedMeshSphere\";",
                "",
                "        this.layoutInstances(radius, instanceCount, offsetX, offsetY, offsetZ, maxYCount, maxZCount);",
                "",
                "        object.get3DRendererObject().add(this.instancedMesh);",
                "    }",
                "",
                "    layoutInstances(radius, instanceCount, offsetX, offsetY, offsetZ, maxYCount, maxZCount) {",
                "        let x = 0, y = 0, z = 0;",
                "        let yCount = 0, zCount = 0;",
                "        const effectiveDiameter = radius * 2;",
                "",
                "        for (let i = 0; i < instanceCount; i++) {",
                "            const matrix = new THREE.Matrix4();",
                "            const position = new THREE.Vector3(x, y, z);",
                "            const quaternion = new THREE.Quaternion(); ",
                "            const scale = new THREE.Vector3(1, 1, 1); ",
                "",
                "            matrix.compose(position, quaternion, scale);",
                "            this.instancedMesh.setMatrixAt(i, matrix);",
                "",
                "            if (++yCount >= maxYCount) {",
                "                yCount = 0;",
                "                y = 0;",
                "                z += effectiveDiameter + offsetZ; // Move up along the Z axis for a new vertical layer.",
                "",
                "                if (++zCount >= maxZCount) {",
                "                    zCount = 0;",
                "                    z = 0; // Reset Z position",
                "                    x += effectiveDiameter + offsetX; // Move along the X axis for a new line",
                "                }",
                "            } else {",
                "                y += effectiveDiameter + offsetY; // Move along the Y axis within the same layer",
                "            }",
                "",
                "            this.instancedMesh.instanceMatrix.needsUpdate = true;",
                "        }",
                "    }",
                "}",
                "",
                "// Expose the Sphere3DRenderer to be available as part of the sphere3DExtension.",
                "gdjs.__sphere3DExtension = {",
                "    Sphere3DRenderer",
                "};"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "VarGlobalTxt"
              },
              "parameters": [
                "_customThreeObject_type",
                "=",
                "\"torus\""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (gdjs.__torus3DExtension) {",
                "    return;",
                "}",
                "",
                "class Torus3DRenderer {",
                "    /** @type {gdjs.CustomRuntimeObject} */",
                "    object;",
                "    /** @type {THREE.InstancedMesh} */",
                "    instancedMesh;",
                "",
                "    /**",
                "     * @param {gdjs.CustomRuntimeObject} object - The custom runtime object.",
                "     * @param {number} radius - Radius of the torus.",
                "     * @param {number} tube - Diameter of the tube.",
                "     * @param {number} radialSegments - Number of segments around the radius of the torus.",
                "     * @param {number} tubularSegments - Number of segments around the tube.",
                "     * @param {number} arc - Central angle in radians (2*PI is a full torus).",
                "     * @param {number} instanceCount - Number of instances to render.",
                "     * @param {number} offsetX - Offset between instances on the X axis.",
                "     * @param {number} offsetY - Offset between instances on the Y axis.",
                "     * @param {number} offsetZ - Offset between instances on the Z axis.",
                "     * @param {number} horizCountMax - Max instances in the horizontal (Y) line.",
                "     * @param {number} vertCountMax - Max instances in the vertical (Z) lines before moving along the X axis.",
                "     */",
                "    constructor(object, radius, tube, radialSegments, tubularSegments, arc, instanceCount, offsetX, offsetY, offsetZ, maxYCount, maxZCount) {",
                "        this.object = object;",
                "",
                "        const geometry = new THREE.TorusGeometry(radius, tube, radialSegments, tubularSegments, arc);",
                "        const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });",
                "        this.instancedMesh = new THREE.InstancedMesh(geometry, material, instanceCount);",
                "        this.instancedMesh.name = object.name || \"InstancedMeshTorus\";",
                "",
                "        this.layoutInstances(radius, tube, instanceCount, offsetX, offsetY, offsetZ, maxYCount, maxZCount);",
                "",
                "        object.get3DRendererObject().add(this.instancedMesh);",
                "    }",
                "",
                "    layoutInstances(radius, tube, instanceCount, offsetX, offsetY, offsetZ, maxYCount, maxZCount) {",
                "        let x = 0, y = 0, z = 0;",
                "        let yCount = 0, zCount = 0;",
                "        const effectiveDiameter = (radius + tube) * 2; // An approximation for placing instances",
                "",
                "        for (let i = 0; i < instanceCount; i++) {",
                "            const matrix = new THREE.Matrix4();",
                "            const position = new THREE.Vector3(x, y, z);",
                "            const quaternion = new THREE.Quaternion();",
                "            const scale = new THREE.Vector3(1, 1, 1);",
                "",
                "            matrix.compose(position, quaternion, scale);",
                "            this.instancedMesh.setMatrixAt(i, matrix);",
                "",
                "            if (++yCount >= maxYCount) {",
                "                yCount = 0;",
                "                y = 0;",
                "                z += effectiveDiameter + offsetZ; // Move up along the Z axis for a new vertical layer.",
                "",
                "                if (++zCount >= maxZCount) {",
                "                    zCount = 0;",
                "                    z = 0; // Reset Z position",
                "                    x += effectiveDiameter + offsetX; // Move along the X axis for a new line",
                "                }",
                "            } else {",
                "                y += effectiveDiameter + offsetY; // Move along the Y axis within the same layer",
                "            }",
                "",
                "            this.instancedMesh.instanceMatrix.needsUpdate = true;",
                "        }",
                "    }",
                "}",
                "",
                "// Expose the Torus3DRenderer to be available as part of the torus3DExtension.",
                "gdjs.__torus3DExtension = {",
                "    Torus3DRenderer",
                "};"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "VarGlobalTxt"
              },
              "parameters": [
                "_customThreeObject_type",
                "=",
                "\"tube\""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "class Tube3DRenderer {",
                "",
                "    object;",
                "    instancedMesh;",
                "",
                "    constructor(object, tubularSegments, radius, radiusSegments, closed, instanceCount, offsetX, offsetY, offsetZ, segmentLengths, horizontalAngles, verticalAngles, segmentCount, tubeThickness) {",
                "        this.object = object;",
                "",
                "        segmentLengths = segmentLengths.split(\",\").map(Number);",
                "        horizontalAngles = horizontalAngles.split(\",\").map(Number);",
                "        verticalAngles = verticalAngles.split(\",\").map(Number);",
                "",
                "        const shape = new THREE.Shape();",
                "        shape.absarc(0, 0, tubeThickness + radius, 0, Math.PI * 2, false);",
                "        const hole = new THREE.Path();",
                "        hole.absarc(0, 0, tubeThickness, 0, Math.PI * 2, true);",
                "        shape.holes.push(hole);",
                "",
                "        const extrudeSettings = {",
                "            steps: tubularSegments,",
                "            bevelEnabled: false",
                "        };",
                "",
                "        const material = new THREE.MeshStandardMaterial({ color: 0xff0000, side: THREE.DoubleSide });",
                "        let totalBufferGeometry = new THREE.BufferGeometry();",
                "",
                "        for (let j = 0; j < instanceCount; j++) {",
                "            const points = [];",
                "            for (let i = 0; i <= segmentCount; i++) {",
                "                const segmentLength = segmentLengths[i % segmentLengths.length] + j * offsetY;",
                "                const horizontalAngle = horizontalAngles[i % horizontalAngles.length] * (Math.PI / 180);",
                "                const verticalAngle = verticalAngles[i % verticalAngles.length] * (Math.PI / 180);",
                "",
                "                const directionVector = new THREE.Vector3(",
                "                    Math.cos(verticalAngle) * Math.cos(horizontalAngle),",
                "                    Math.sin(verticalAngle),",
                "                    Math.cos(verticalAngle) * Math.sin(horizontalAngle)",
                "                );",
                "                directionVector.normalize().multiplyScalar(segmentLength);",
                "                const newPoint = new THREE.Vector3();",
                "                if (points.length > 0) {",
                "                    newPoint.addVectors(points[points.length - 1], directionVector);",
                "                } else {",
                "                    newPoint.copy(directionVector);",
                "                }",
                "                points.push(newPoint);",
                "            }",
                "",
                "            const path = new THREE.CatmullRomCurve3(points);",
                "            extrudeSettings.extrudePath = path;",
                "",
                "            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);",
                "            ",
                "            const bufferGeometry = geometry.toBufferGeometry();",
                "            bufferGeometry.translate(j * offsetX, 0, j * offsetZ); // Translate each tube",
                "            totalBufferGeometry = THREE_ADDONS.BufferGeometryUtils.mergeBufferGeometries([totalBufferGeometry, bufferGeometry]);",
                "        }",
                "",
                "        this.instancedMesh = new THREE.Mesh(totalBufferGeometry, material);",
                "        this.instancedMesh.name = object.name || \"InstancedMeshTube\";",
                "        object.get3DRendererObject().add(this.instancedMesh);",
                "    }",
                "}",
                "",
                "gdjs.__tube3DExtension = {",
                "    Tube3DRenderer",
                "};"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "VarGlobalTxt"
              },
              "parameters": [
                "_customThreeObject_type",
                "=",
                "\"dodecahedron\""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (gdjs.__dodecahedron3DExtension) {",
                "    return;",
                "}",
                "",
                "class Dodecahedron3DRenderer {",
                "    /** @type {gdjs.CustomRuntimeObject} */",
                "    object;",
                "    /** @type {THREE.InstancedMesh} */",
                "    instancedMesh;",
                "",
                "    /**",
                "     * @param {gdjs.CustomRuntimeObject} object - The custom runtime object.",
                "     * @param {number} radius - Radius of the dodecahedron instances.",
                "     * @param {number} detail - The number of times to subdivide each triangle face (Optional; default is 0).",
                "     * @param {number} instanceCount - Number of instances to render.",
                "     * @param {number} offsetX - Offset between instances on the X axis.",
                "     * @param {number} offsetY - Offset between instances on the Y axis.",
                "     * @param {number} offsetZ - Offset between instances on the Z axis.",
                "     * @param {number} horizCountMax - Max instances in the horizontal (Y) line.",
                "     * @param {number} vertCountMax - Max instances in the vertical (Z) lines before moving along the X axis.",
                "     */",
                "    constructor(object, radius, detail, instanceCount, offsetX, offsetY, offsetZ, maxYCount, maxZCount) {",
                "        this.object = object;",
                "",
                "        const geometry = new THREE.DodecahedronGeometry(radius, detail);",
                "        const material = new THREE.MeshStandardMaterial({ color: 0xff0000 });",
                "        this.instancedMesh = new THREE.InstancedMesh(geometry, material, instanceCount);",
                "        this.instancedMesh.name = object.name || \"InstancedMeshDodecahedron\";",
                "",
                "        this.layoutInstances(radius, instanceCount, offsetX, offsetY, offsetZ, maxYCount, maxZCount);",
                "",
                "        object.get3DRendererObject().add(this.instancedMesh);",
                "    }",
                "",
                "    layoutInstances(radius, instanceCount, offsetX, offsetY, offsetZ, maxYCount, maxZCount) {",
                "        let x = 0, y = 0, z = 0;",
                "        let yCount = 0, zCount = 0;",
                "        const effectiveDiameter = radius * 2; // Approximation of the distance for placing instances",
                "",
                "        for (let i = 0; i < instanceCount; i++) {",
                "            const matrix = new THREE.Matrix4();",
                "            const position = new THREE.Vector3(x, y, z);",
                "            const quaternion = new THREE.Quaternion();",
                "            const scale = new THREE.Vector3(1, 1, 1);",
                "",
                "            matrix.compose(position, quaternion, scale);",
                "            this.instancedMesh.setMatrixAt(i, matrix);",
                "",
                "            if (++yCount >= maxYCount) {",
                "                yCount = 0;",
                "                y = 0;",
                "                z += effectiveDiameter + offsetZ; // Move up along the Z axis for a new vertical layer.",
                "",
                "                if (++zCount >= maxZCount) {",
                "                    zCount = 0;",
                "                    z = 0; // Reset Z position",
                "                    x += effectiveDiameter + offsetX; // Move along the X axis for a new line",
                "                }",
                "            } else {",
                "                y += effectiveDiameter + offsetY; // Move along the Y axis within the same layer",
                "            }",
                "",
                "            this.instancedMesh.instanceMatrix.needsUpdate = true;",
                "        }",
                "    }",
                "}",
                "",
                "// Expose the Dodecahedron3DRenderer to be available as part of the dodecahedron3DExtension.",
                "gdjs.__dodecahedron3DExtension = {",
                "    Dodecahedron3DRenderer",
                "};"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "VarGlobalTxt"
              },
              "parameters": [
                "_customThreeObject_type",
                "=",
                "\"original_geometry\""
              ]
            }
          ],
          "actions": [],
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "class Model3DRenderer {\r",
                "    /** @type {gdjs.CustomRuntimeObject3D} */\r",
                "    object;\r",
                "\r",
                "    /**\r",
                "     * Constructor for the Model3DRenderer.\r",
                "     * @param {gdjs.CustomRuntimeObject} object - The custom runtime object.\r",
                "     * @param {string} customName - Name of the instanced mesh.\r",
                "     * @param {string} pathGLB - GLB file name.\r",
                "     * @param {number} scaleX - Width of the cube instances.\r",
                "     * @param {number} scaleY - Height of the cube instances.\r",
                "     * @param {number} scaleZ - Depth of the cube instances.\r",
                "     * @param {number} instanceCount - Number of instances to render.\r",
                "     * @param {number} offsetX - Offset between instances on the X axis.\r",
                "     * @param {number} offsetY - Offset between instances on the Y axis.\r",
                "     * @param {number} offsetZ - Offset between instances on the Z axis.\r",
                "     * @param {number} maxY - Max instances in the horizontal (Y) line.\r",
                "     * @param {number} maxZ - Max instances in the vertical (Z) lines before moving along the X axis.\r",
                "     */\r",
                "    constructor(object, customName, pathGLB, scaleX, scaleY, scaleZ, instanceCount, offsetX, offsetY, offsetZ, maxY, maxZ) {\r",
                "        this.object = object;\r",
                "        this.scaleX = scaleX;\r",
                "        this.scaleY = scaleY;\r",
                "        this.scaleZ = scaleZ;\r",
                "\r",
                "        const gltfLoader = new THREE_ADDONS.GLTFLoader();\r",
                "        const dracoLoader = new THREE_ADDONS.DRACOLoader();\r",
                "        dracoLoader.setDecoderPath('./pixi-renderers/draco/gltf/');\r",
                "        gltfLoader.setDRACOLoader(dracoLoader);\r",
                "\r",
                "        gltfLoader.load(pathGLB, (gltf) => {\r",
                "            const modelScene = gltf.scene;\r",
                "\r",
                "\r",
                "            const traverseScene = (node) => {\r",
                "                node.children.forEach((child, index) => {\r",
                "\r",
                "\r",
                "                    if (child.isMesh) {\r",
                "\r",
                "                        if (child.geometry) {\r",
                "                            this.processMesh(child, customName, instanceCount, offsetX, offsetY, offsetZ, maxY, maxZ);\r",
                "                        }\r",
                "                    }\r",
                "\r",
                " \r",
                "                    traverseScene(child);\r",
                "                });\r",
                "            };\r",
                "\r",
                "            traverseScene(modelScene);\r",
                "\r",
                "            if (!this.instancedMesh) {\r",
                "\r",
                "            }\r",
                "        }, undefined, (error) => {\r",
                "\r",
                "        });\r",
                "    }\r",
                "\r",
                "    processMesh(mesh, customName, instanceCount, offsetX, offsetY, offsetZ, maxY, maxZ) {\r",
                "        mesh.geometry.scale(this.scaleX, this.scaleY, this.scaleZ);\r",
                "        mesh.geometry.computeBoundingBox();\r",
                "\r",
                "        const aabb = mesh.geometry.boundingBox;\r",
                "        const instancedMesh = new THREE.InstancedMesh(mesh.geometry, mesh.material, instanceCount);\r",
                "        this.instancedMesh = instancedMesh;\r",
                "        this.instancedMesh.name = customName;\r",
                "        this.object.get3DRendererObject().add(instancedMesh);\r",
                "        mesh.geometry.dispose();\r",
                "        mesh.material.dispose();\r",
                "\r",
                "        if (aabb) {\r",
                "            this.layoutInstances(aabb, instanceCount, offsetX, offsetY, offsetZ, maxY, maxZ);\r",
                "        }\r",
                "    }\r",
                "\r",
                "    layoutInstances(aabb, instanceCount, offsetX, offsetY, offsetZ, maxY, maxZ) {\r",
                "        const width = aabb.max.x - aabb.min.x;\r",
                "        const height = aabb.max.y - aabb.min.y;\r",
                "        const depth = aabb.max.z - aabb.min.z;\r",
                "\r",
                "        let x = 0, y = 0, z = 0;\r",
                "        let yCount = 0, zCount = 0;\r",
                "\r",
                "        for (let i = 0; i < instanceCount; i++) {\r",
                "            const matrix = new THREE.Matrix4();\r",
                "            const position = new THREE.Vector3(x, y, z);\r",
                "            const quaternion = new THREE.Quaternion();\r",
                "\r",
                "            matrix.compose(position, quaternion, new THREE.Vector3(1, 1, 1));\r",
                "            this.instancedMesh.setMatrixAt(i, matrix);\r",
                "            this.instancedMesh.instanceMatrix.needsUpdate = true;\r",
                "\r",
                "            if (++yCount >= maxY) {\r",
                "                yCount = 0;\r",
                "                y = 0;\r",
                "                z += depth + offsetZ;\r",
                "\r",
                "                if (++zCount >= maxZ) {\r",
                "                    zCount = 0;\r",
                "                    z = 0;\r",
                "                    x += width + offsetX;\r",
                "                }\r",
                "            } else {\r",
                "                y += height + offsetY;\r",
                "            }\r",
                "        }\r",
                "    }\r",
                "}\r",
                "\r",
                "gdjs.__model3DExtension = {\r",
                "    Model3DRenderer\r",
                "};\r",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ]
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Synchronize names (ThreeJS name = Gdevelop name)",
      "fullName": "Synchronize names (ThreeJS name = Gdevelop name)",
      "functionType": "Action",
      "name": "SynchronizeNames",
      "sentence": "Synchronize names for: _PARAM1_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh || node.type === 'ParticleEmitter' || node.isLight) {",
            "            node.name = objects[0].getName();",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Mesh",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Wobble",
      "fullName": "Wobble",
      "functionType": "Action",
      "name": "Wobble",
      "sentence": "Wobble",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function addRandomWobbleEffectToMeshInstances(runtimeScene, meshName, minHorizontalStretch, maxHorizontalStretch, minVerticalStretch, maxVerticalStretch, cycleDuration, randomnessFactor, startIndex, endIndex) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const mesh = threeScene.getObjectByName(meshName);",
            "    if (!mesh) {",
            "        return;",
            "    }",
            "",
            "    if (!mesh.isInstancedMesh) {",
            "        endIndex = Math.min(endIndex, (mesh.children.length > 0 ? mesh.children.length : 1) - 1);",
            "    } else {",
            "        endIndex = Math.min(endIndex, mesh.count - 1);",
            "    }",
            "",
            "    const instanceCount = endIndex - startIndex + 1;",
            "    const instanceData = new Array(instanceCount).fill(null).map(() => {",
            "        const randomness = Math.random() * randomnessFactor;",
            "        return {",
            "            horizontalPhaseOffset: Math.random() * Math.PI * 2,",
            "            verticalPhaseOffset: Math.random() * Math.PI * 2,",
            "            currentHorizontalScale: 1,",
            "            currentVerticalScale: 1,",
            "            lastCycleTime: 0,",
            "            minHorizontalStretch: minHorizontalStretch + randomness,",
            "            maxHorizontalStretch: maxHorizontalStretch + randomness,",
            "            minVerticalStretch: minVerticalStretch + randomness,",
            "            maxVerticalStretch: maxVerticalStretch + randomness",
            "        };",
            "    });",
            "",
            "    const wobble = (time, instanceIndex) => {",
            "        const instance = instanceData[instanceIndex];",
            "",
            "        const horizontalT = (time / cycleDuration + instance.horizontalPhaseOffset) % 1;",
            "        const verticalT = (time / cycleDuration + instance.verticalPhaseOffset) % 1;",
            "",
            "        const horizontalAmplitude = (instance.maxHorizontalStretch - instance.minHorizontalStretch) / 2;",
            "        const verticalAmplitude = (instance.maxVerticalStretch - instance.minVerticalStretch) / 2;",
            "",
            "        const horizontalStretch = ",
            "            (instance.minHorizontalStretch + instance.maxHorizontalStretch) / 2 + ",
            "            horizontalAmplitude * Math.sin(horizontalT * Math.PI * 2);",
            "",
            "        const verticalStretch = ",
            "            (instance.minVerticalStretch + instance.maxVerticalStretch) / 2 + ",
            "            verticalAmplitude * Math.sin(verticalT * Math.PI * 2);",
            "",
            "        return { horizontal: horizontalStretch, vertical: verticalStretch };",
            "    };",
            "",
            "    let startTime = Date.now();",
            "    let lastTime = startTime;",
            "",
            "    function animate() {",
            "        const currentTime = Date.now();",
            "        const elapsedTime = (currentTime - startTime) / 1000; // Convert to seconds",
            "        const deltaTime = (currentTime - lastTime) / 1000; // Time since last frame",
            "        lastTime = currentTime;",
            "",
            "        if (mesh.isInstancedMesh) {",
            "            for (let i = startIndex; i <= endIndex; i++) {",
            "                const instanceIndex = i - startIndex;",
            "                const targetStretch = wobble(elapsedTime, instanceIndex);",
            "                const instance = instanceData[instanceIndex];",
            "",
            "                // Smooth interpolation",
            "                instance.currentHorizontalScale += (targetStretch.horizontal - instance.currentHorizontalScale) * 5 * deltaTime;",
            "                instance.currentVerticalScale += (targetStretch.vertical - instance.currentVerticalScale) * 5 * deltaTime;",
            "",
            "                const matrix = new THREE.Matrix4();",
            "                mesh.getMatrixAt(i, matrix);",
            "                const position = new THREE.Vector3();",
            "                const quaternion = new THREE.Quaternion();",
            "                const scale = new THREE.Vector3();",
            "                matrix.decompose(position, quaternion, scale);",
            "                ",
            "                scale.x = scale.y = instance.currentHorizontalScale;",
            "                scale.z = instance.currentVerticalScale;",
            "                ",
            "                matrix.compose(position, quaternion, scale);",
            "                mesh.setMatrixAt(i, matrix);",
            "            }",
            "            mesh.instanceMatrix.needsUpdate = true;",
            "        } else {",
            "            const meshes = (mesh.children.length > 0 ? [mesh].concat(mesh.children) : [mesh]);",
            "            meshes.forEach((m, index) => {",
            "                if (index >= startIndex && index <= endIndex) {",
            "                    const instanceIndex = index - startIndex;",
            "                    const targetStretch = wobble(elapsedTime, instanceIndex);",
            "                    const instance = instanceData[instanceIndex];",
            "",
            "                    // Smooth interpolation",
            "                    instance.currentHorizontalScale += (targetStretch.horizontal - instance.currentHorizontalScale) * 5 * deltaTime;",
            "                    instance.currentVerticalScale += (targetStretch.vertical - instance.currentVerticalScale) * 5 * deltaTime;",
            "",
            "                    m.scale.x = m.scale.y = instance.currentHorizontalScale;",
            "                    m.scale.z = instance.currentVerticalScale;",
            "                    m.updateMatrix();",
            "                }",
            "            });",
            "        }",
            "",
            "        mesh.updateMatrixWorld();",
            "",
            "        requestAnimationFrame(animate);",
            "    }",
            "",
            "    animate();",
            "}",
            "",
            "if (objects.length > 0) {",
            "    let objectMesh = objects[0];",
            "    let minHorizontalStretch = parseFloat(eventsFunctionContext.getArgument(\"minHorizontalStretch\"));",
            "    let maxHorizontalStretch = parseFloat(eventsFunctionContext.getArgument(\"maxHorizontalStretch\"));",
            "    let minVerticalStretch = parseFloat(eventsFunctionContext.getArgument(\"minVerticalStretch\"));",
            "    let maxVerticalStretch = parseFloat(eventsFunctionContext.getArgument(\"maxVerticalStretch\"));",
            "    let cycleDuration = parseFloat(eventsFunctionContext.getArgument(\"cycleDuration\"));",
            "    let randomnessFactor = parseFloat(eventsFunctionContext.getArgument(\"randomnessFactor\"));",
            "    let startIndex = parseInt(eventsFunctionContext.getArgument(\"startIndex\"), 10);",
            "    let endIndex = parseInt(eventsFunctionContext.getArgument(\"endIndex\"), 10);",
            "    ",
            "    addRandomWobbleEffectToMeshInstances(runtimeScene, objectMesh.getName(), minHorizontalStretch, maxHorizontalStretch, minVerticalStretch, maxVerticalStretch, cycleDuration, randomnessFactor, startIndex, endIndex);",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "minHorizontalStretch",
          "name": "minHorizontalStretch",
          "type": "expression"
        },
        {
          "description": "maxHorizontalStretch",
          "name": "maxHorizontalStretch",
          "type": "expression"
        },
        {
          "description": "minVerticalStretch",
          "name": "minVerticalStretch",
          "type": "expression"
        },
        {
          "description": "maxVerticalStretch",
          "name": "maxVerticalStretch",
          "type": "expression"
        },
        {
          "description": "cycleDuration",
          "name": "cycleDuration",
          "type": "expression"
        },
        {
          "description": "randomnessFactor",
          "name": "randomnessFactor",
          "type": "expression"
        },
        {
          "description": "startIndex",
          "name": "startIndex",
          "type": "expression"
        },
        {
          "description": "endIndex",
          "name": "endIndex",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Frustum culling",
      "fullName": "Frustum culling",
      "functionType": "Action",
      "name": "FrustumCulling",
      "sentence": "Frustum culling for: _PARAM1_ Value: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material) {",
            "            const frustum = eventsFunctionContext.getArgument(\"frustumCulled\");         ",
            "            node.material.frustumCulled = frustum; ",
            "            node.frustumCulled = frustum; ",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Use frustum culling",
          "name": "frustumCulled",
          "type": "trueorfalse"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Instanced mesh raycast by angle",
      "fullName": "Instanced mesh raycast by angle",
      "functionType": "Action",
      "group": "Raycasting",
      "name": "RaycastByAngle",
      "sentence": "Instanced mesh raycast by angle Ray Name: _PARAM1_ Target objects names: _PARAM2_ fromX: _PARAM3_ fromY: _PARAM4_ fromZ: _PARAM5_ hAngle: _PARAM6_ vAngle: _PARAM7_ Distance: _PARAM8_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (!runtimeScene.getLayer) {\r",
            "  return;\r",
            "}\r",
            "\r",
            "const layer = runtimeScene.getLayer(\"\");\r",
            "const threeCamera = layer.getRenderer().getThreeCamera();\r",
            "const threeScene = layer.getRenderer().getThreeScene();\r",
            "const renderer = runtimeScene.getGame().getRenderer().getThreeRenderer();\r",
            "\r",
            "if (!threeScene.raycasterMap) {\r",
            "  threeScene.raycasterMap = new Map();\r",
            "}\r",
            "\r",
            "const fromX = eventsFunctionContext.getArgument(\"fromX\");\r",
            "const fromY = eventsFunctionContext.getArgument(\"fromY\");\r",
            "const fromZ = eventsFunctionContext.getArgument(\"fromZ\");\r",
            "const horizontalAngleDegrees = eventsFunctionContext.getArgument(\"horizontalAngle\");\r",
            "const verticalAngleDegrees = eventsFunctionContext.getArgument(\"verticalAngle\");\r",
            "const distanceRay = eventsFunctionContext.getArgument(\"distanceRay\");\r",
            "const targetObjects = eventsFunctionContext.getArgument(\"targetNames\").split(',');\r",
            "const varName = eventsFunctionContext.getArgument(\"varName\");\r",
            "const varText = eventsFunctionContext.getArgument(\"varText\");\r",
            "\r",
            "const horizontalAngleRadians = THREE.MathUtils.degToRad(horizontalAngleDegrees);\r",
            "const verticalAngleRadians = THREE.MathUtils.degToRad(verticalAngleDegrees);\r",
            "\r",
            "const direction = new THREE.Vector3(\r",
            "  Math.cos(verticalAngleRadians) * Math.cos(horizontalAngleRadians),\r",
            "  Math.cos(verticalAngleRadians) * -Math.sin(horizontalAngleRadians),\r",
            "  Math.sin(verticalAngleRadians)\r",
            ").normalize();\r",
            "\r",
            "const raycaster = new THREE.Raycaster(new THREE.Vector3(fromX, -fromY, fromZ), direction);\r",
            "raycaster.far = distanceRay;\r",
            "const rayName = eventsFunctionContext.getArgument(\"rayName\");\r",
            "threeScene.raycasterMap.set(rayName, raycaster);\r",
            "\r",
            "var raycastingVar = runtimeScene.getVariables().get(\"_raycasting_instanced_mesh\");\r",
            "\r",
            "const intersects = [];\r",
            "threeScene.traverse((child) => {\r",
            "  if (child.isMesh && targetObjects.includes(child.name)) {\r",
            "    var childIntersects = raycaster.intersectObject(child, true);\r",
            "    childIntersects.forEach((intersect) => {\r",
            "      intersects.push(intersect);\r",
            "    });\r",
            "  }\r",
            "});\r",
            "\r",
            "if (intersects.length > 0) {\r",
            "  const firstIntersect = intersects[0];\r",
            "  raycastingVar.getChildNamed(rayName + \"x\").setNumber(firstIntersect.point.x);\r",
            "  raycastingVar.getChildNamed(rayName + \"y\").setNumber(firstIntersect.point.y);\r",
            "  raycastingVar.getChildNamed(rayName + \"z\").setNumber(firstIntersect.point.z);\r",
            "  raycastingVar.getChildNamed(rayName + \"distance\").setNumber(firstIntersect.distance);\r",
            "  raycastingVar.getChildNamed(rayName + \"_intersected\").setString(\"true\");\r",
            "  \r",
            "  const intersectedObject = firstIntersect.object;\r",
            "  const instanceVariableName = `_${intersectedObject.name}_${firstIntersect.instanceId}_${varName}`;\r",
            "  runtimeScene.getVariables().get(instanceVariableName).setString(varText);\r",
            "} else {\r",
            "  raycastingVar.getChildNamed(rayName + \"_intersected\").setString(\"false\");\r",
            "}\r",
            "\r",
            "renderer.render(threeScene, threeCamera);"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Ray name",
          "name": "rayName",
          "type": "string"
        },
        {
          "description": "Target objects names (\"name1, name2, name3\")",
          "name": "targetNames",
          "type": "string"
        },
        {
          "description": "From X",
          "name": "fromX",
          "type": "expression"
        },
        {
          "description": "From Y",
          "name": "fromY",
          "type": "expression"
        },
        {
          "description": "From Z",
          "name": "fromZ",
          "type": "expression"
        },
        {
          "description": "horizontalAngle",
          "name": "horizontalAngle",
          "type": "expression"
        },
        {
          "description": "verticalAngle",
          "name": "verticalAngle",
          "type": "expression"
        },
        {
          "description": "Distance",
          "name": "distanceRay",
          "type": "expression"
        },
        {
          "description": "Intersected instance varName equal to text",
          "name": "varName",
          "type": "string"
        },
        {
          "description": "Text",
          "name": "varText",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Instanced mesh raycast to point",
      "fullName": "Instanced mesh raycast to point",
      "functionType": "Action",
      "group": "Raycasting",
      "name": "Raycast",
      "sentence": "Instanced mesh raycast Ray Name: _PARAM1_ Target objects names: _PARAM2_ fromX: _PARAM3_ fromY: _PARAM4_ fromZ: _PARAM5_ toX: _PARAM6_ toY: _PARAM7_ toZ: _PARAM8_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const layer = runtimeScene.getLayer(\"\");\r",
            "const layerRenderer = layer.getRenderer();\r",
            "const threeScene = layerRenderer.getThreeScene();\r",
            "const threeCamera = layerRenderer.getThreeCamera();\r",
            "const renderer = runtimeScene.getGame().getRenderer().getThreeRenderer();\r",
            "\r",
            "if (!threeScene.raycasterMap) {\r",
            "  threeScene.raycasterMap = new Map();\r",
            "}\r",
            "\r",
            "const fromX = eventsFunctionContext.getArgument(\"fromX\");\r",
            "const fromY = eventsFunctionContext.getArgument(\"fromY\");\r",
            "const fromZ = eventsFunctionContext.getArgument(\"fromZ\");\r",
            "const toX = eventsFunctionContext.getArgument(\"toX\");\r",
            "const toY = eventsFunctionContext.getArgument(\"toY\");\r",
            "const toZ = eventsFunctionContext.getArgument(\"toZ\");\r",
            "const objectList = eventsFunctionContext.getArgument(\"targetNames\").split(',');\r",
            "\r",
            "var start = new THREE.Vector3(fromX, -fromY, fromZ); \r",
            "var end = new THREE.Vector3(toX, -toY, toZ); \r",
            "var direction = new THREE.Vector3().subVectors(end, start).normalize();\r",
            "\r",
            "var raycaster = new THREE.Raycaster(start, direction);\r",
            "const rayName = eventsFunctionContext.getArgument(\"rayName\");\r",
            "threeScene.raycasterMap.set(rayName, raycaster);  \r",
            "\r",
            "var raycastingVar = runtimeScene.getVariables().get(\"_raycasting_instanced_mesh\");\r",
            "var instancedMeshIntersects = [];\r",
            "\r",
            "threeScene.traverse((child) => {\r",
            "    if (child.isMesh && objectList.includes(child.name)) {\r",
            "        var intersects = raycaster.intersectObject(child, true);\r",
            "        intersects.forEach((intersect) => {\r",
            "            instancedMeshIntersects.push(intersect);\r",
            "        });\r",
            "    }\r",
            "});\r",
            "\r",
            "instancedMeshIntersects.sort((a, b) => a.distance - b.distance);\r",
            "\r",
            "if (instancedMeshIntersects.length) {\r",
            "    const firstIntersect = instancedMeshIntersects[0];\r",
            "    raycastingVar.getChildNamed(rayName+\"x\").setNumber(firstIntersect.point.x);\r",
            "    raycastingVar.getChildNamed(rayName+\"y\").setNumber(firstIntersect.point.y);\r",
            "    raycastingVar.getChildNamed(rayName+\"z\").setNumber(firstIntersect.point.z);\r",
            "    raycastingVar.getChildNamed(rayName+\"distance\").setNumber(firstIntersect.distance);\r",
            "    raycastingVar.getChildNamed(rayName+\"intersected\").setString(\"true\");\r",
            "} else {\r",
            "    raycastingVar.getChildNamed(rayName+\"intersected\").setString(\"false\");\r",
            "}\r",
            "\r",
            "renderer.render(threeScene, threeCamera);"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Ray name",
          "name": "rayName",
          "type": "string"
        },
        {
          "description": "Target objects names (\"name1, name2, name3\")",
          "name": "targetNames",
          "type": "string"
        },
        {
          "description": "From X",
          "name": "fromX",
          "type": "expression"
        },
        {
          "description": "From Y",
          "name": "fromY",
          "type": "expression"
        },
        {
          "description": "From Z",
          "name": "fromZ",
          "type": "expression"
        },
        {
          "description": "To X",
          "name": "toX",
          "type": "expression"
        },
        {
          "description": "To Y",
          "name": "toY",
          "type": "expression"
        },
        {
          "description": "To Z",
          "name": "toZ",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "FindGdevelopObjectName (console debug)",
      "fullName": "FindGdevelopObjectName (console debug)",
      "functionType": "Action",
      "group": "Debug tools",
      "name": "FindGdevelopObjectName",
      "sentence": "FindGdevelopObjectName (console debug)",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const layer = runtimeScene.getLayer(\"\");",
            "const layerRenderer = layer.getRenderer();",
            "const threeScene = layerRenderer.getThreeScene();",
            "",
            "threeScene.traverse((child) => {",
            "    if (child.isMesh || child.type === 'ParticleEmitter'|| child.isPoints) {",
            "",
            "        console.log(child.name);",
            "    }",
            "});"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Set grid",
      "fullName": "Set grid",
      "functionType": "Action",
      "getterName": "IsScaleOfInstance",
      "group": "Instances by index",
      "name": "SetGrid",
      "sentence": "Set grid for: _PARAM1_   Start Index: _PARAM2_ End Index: _PARAM3_ startX: _PARAM4_ startY: _PARAM5_ startZ: _PARAM6_ offsetX: _PARAM7_ offsetY: _PARAM8_ offsetZ: _PARAM9_ maxY: _PARAM10_ maxZ: _PARAM11_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function parseOffset(offsetStr) {",
            "  if (!offsetStr) {",
            "    return 0;",
            "  }",
            "  const parts = offsetStr.split(',');",
            "  if (parts.length === 2) {",
            "    const min = parseFloat(parts[0]);",
            "    const max = parseFloat(parts[1]);",
            "    return Math.random() * (max - min) + min;",
            "  }",
            "  return parseFloat(offsetStr);",
            "}",
            "",
            "function createGridFromInstances(runtimeScene, meshName, startIndex, endIndex, startPosition, offsetXStr, offsetYStr, offsetZStr, maxY, maxZ) {",
            "  const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "  const instancedMesh = threeScene.getObjectByName(meshName);",
            "",
            "  if (!instancedMesh || !instancedMesh.isInstancedMesh) {",
            "    return;",
            "  }",
            "",
            "  const geometry = instancedMesh.geometry;",
            "  geometry.computeBoundingBox();",
            "  const boundingBox = geometry.boundingBox;",
            "  const baseWidth = boundingBox.max.x - boundingBox.min.x;",
            "  const baseHeight = boundingBox.max.y - boundingBox.min.y;",
            "  const baseDepth = boundingBox.max.z - boundingBox.min.z;",
            "",
            "  let currentX = startPosition.x;",
            "  let currentY = startPosition.y;",
            "  let currentZ = startPosition.z;",
            "  let countY = 0;",
            "  let countZ = 0;",
            "",
            "  for (let i = startIndex; i <= endIndex && i < instancedMesh.count; i++) {",
            "    const matrix = new THREE.Matrix4();",
            "    instancedMesh.getMatrixAt(i, matrix);",
            "",
            "    const position = new THREE.Vector3();",
            "    const quaternion = new THREE.Quaternion();",
            "    const scale = new THREE.Vector3();",
            "    matrix.decompose(position, quaternion, scale);",
            "",
            "    const instanceWidth = baseWidth * scale.x;",
            "    const instanceHeight = baseHeight * scale.y;",
            "    const instanceDepth = baseDepth * scale.z;",
            "",
            "    const offsetX = parseOffset(offsetXStr);",
            "    const offsetY = parseOffset(offsetYStr);",
            "    const offsetZ = parseOffset(offsetZStr);",
            "",
            "    position.set(",
            "      currentX + offsetX,",
            "      currentY + countY * (instanceHeight + offsetY),",
            "      currentZ + countZ * (instanceDepth + offsetZ)",
            "    );",
            "",
            "    matrix.compose(position, quaternion, scale);",
            "    instancedMesh.setMatrixAt(i, matrix);",
            "",
            "    countZ++;",
            "    if (countZ >= maxZ) {",
            "      countZ = 0;",
            "      countY++;",
            "      if (countY >= maxY) {",
            "        countY = 0;",
            "        currentX += instanceWidth + parseOffset(offsetXStr); ",
            "      }",
            "    }",
            "  }",
            "",
            "  instancedMesh.instanceMatrix.needsUpdate = true;",
            "}",
            "",
            "if (objects.length >0){",
            "const objectMesh = objects[0].getName();",
            "const startIndex = parseInt(eventsFunctionContext.getArgument(\"startIndex\"), 10);",
            "const endIndex = parseInt(eventsFunctionContext.getArgument(\"endIndex\"), 10);",
            "const startPosition = { ",
            "  x: parseFloat(eventsFunctionContext.getArgument(\"positionX\")),",
            "  y: parseFloat(eventsFunctionContext.getArgument(\"positionY\")),",
            "  z: parseFloat(eventsFunctionContext.getArgument(\"positionZ\"))",
            "}; ",
            "const offsetXStr = eventsFunctionContext.getArgument(\"offsetX\");",
            "const offsetYStr = eventsFunctionContext.getArgument(\"offsetY\");",
            "const offsetZStr = eventsFunctionContext.getArgument(\"offsetZ\");",
            "const maxY = parseInt(eventsFunctionContext.getArgument(\"maxY\"), 10);",
            "const maxZ = parseInt(eventsFunctionContext.getArgument(\"maxZ\"), 10);",
            "",
            "createGridFromInstances(runtimeScene, objectMesh, startIndex, endIndex, startPosition, offsetXStr, offsetYStr, offsetZStr, maxY, maxZ);",
            "};"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the object",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "startIndex",
          "name": "startIndex",
          "type": "expression"
        },
        {
          "description": "endIndex",
          "name": "endIndex",
          "type": "expression"
        },
        {
          "description": "positionX",
          "name": "positionX",
          "type": "expression"
        },
        {
          "description": "positionY",
          "name": "positionY",
          "type": "expression"
        },
        {
          "description": "positionZ",
          "name": "positionZ",
          "type": "expression"
        },
        {
          "description": "offsetX",
          "longDescription": "Numbers range is possible (example: \"10,250\")",
          "name": "offsetX",
          "type": "string"
        },
        {
          "description": "offsetY",
          "longDescription": "Numbers range is possible (example: \"10,250\")",
          "name": "offsetY",
          "type": "string"
        },
        {
          "description": "offsetZ",
          "longDescription": "Numbers range is possible (example: \"10,250\")",
          "name": "offsetZ",
          "type": "string"
        },
        {
          "description": "maxY",
          "name": "maxY",
          "type": "expression"
        },
        {
          "description": "maxZ",
          "name": "maxZ",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Set position of Instances",
      "fullName": "Set position of Instances",
      "functionType": "Action",
      "getterName": "IsScaleOfInstance",
      "group": "Instances by index",
      "name": "SetPosition",
      "sentence": "Set position of Instances: _PARAM1_  Axis: _PARAM2_  Operator: _PARAM3_ Start Index: _PARAM4_ End Index: _PARAM5_ Position: _PARAM6_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getInstancedMeshInstancePosition(runtimeScene, instancedMeshName, instanceIndex) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const instancedMesh = threeScene.getObjectByName(instancedMeshName);",
            "    const position = { x: 0, y: 0, z: 0 };",
            "",
            "    if (instancedMesh && instancedMesh.isInstancedMesh) {",
            "        const matrix = new THREE.Matrix4();",
            "        instancedMesh.getMatrixAt(instanceIndex, matrix);",
            "",
            "        const vector = new THREE.Vector3();",
            "        vector.setFromMatrixPosition(matrix);",
            "",
            "        position.x = vector.x;",
            "        position.y = vector.y;",
            "        position.z = vector.z;",
            "    }",
            "",
            "    return position;",
            "}",
            "",
            "function changeInstancedMeshInstancesPositionWithOperator(runtimeScene, meshName, targetPosition, startIndex, endIndex, operator, dimension) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const instancedMesh = threeScene.getObjectByName(meshName);",
            "",
            "    if (!instancedMesh) {",
            "        return;",
            "    }",
            "",
            "    startIndex = Math.max(0, startIndex);",
            "    endIndex = Math.min(endIndex, instancedMesh.count - 1);",
            "",
            "    for (let i = startIndex; i <= endIndex; i++) {",
            "        const matrix = new THREE.Matrix4();",
            "        instancedMesh.getMatrixAt(i, matrix);",
            "",
            "        const position = new THREE.Vector3();",
            "        const quaternion = new THREE.Quaternion();",
            "        const scale = new THREE.Vector3();",
            "        matrix.decompose(position, quaternion, scale);",
            "",
            "        if (operator === '=') {",
            "            position[dimension] = targetPosition;",
            "        } else if (operator === '+') {",
            "            position[dimension] += targetPosition;",
            "        } else if (operator === '-') {",
            "            position[dimension] -= targetPosition;",
            "        }",
            "",
            "        matrix.compose(position, quaternion, scale);",
            "        instancedMesh.setMatrixAt(i, matrix);",
            "    }",
            "",
            "    instancedMesh.instanceMatrix.needsUpdate = true;",
            "}",
            "",
            "function changeMeshPosition(runtimeScene, mesh, operator, dimension, targetPosition) {",
            "    mesh.updateMatrixWorld();",
            "    const worldPosition = new THREE.Vector3();",
            "    mesh.getWorldPosition(worldPosition);",
            "",
            "    if (operator === '=') {",
            "        worldPosition[dimension] = targetPosition;",
            "    } else if (operator === '+') {",
            "        worldPosition[dimension] += (dimension === 'y' ? -targetPosition : targetPosition);",
            "    } else if (operator === '-') {",
            "        worldPosition[dimension] -= (dimension === 'y' ? -targetPosition : targetPosition);",
            "    }",
            "",
            "    const parent = mesh.parent || runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const parentInverseMatrixWorld = new THREE.Matrix4().copy(parent.matrixWorld).invert();",
            "    const localPosition = worldPosition.applyMatrix4(parentInverseMatrixWorld);",
            "",
            "    mesh.position.set(localPosition.x, localPosition.y, localPosition.z);",
            "    mesh.updateMatrixWorld(true);",
            "}",
            "",
            "function changeMeshInstancePosition(runtimeScene, mesh, startIndex, endIndex, operator, dimension, targetPosition) {",
            "    if (mesh.isInstancedMesh) {",
            "        changeInstancedMeshInstancesPositionWithOperator(runtimeScene, mesh.name, targetPosition, startIndex, endIndex, operator, dimension);",
            "    } else {",
            "        sceneTraverse(runtimeScene, mesh.name, (object) => {",
            "            changeMeshPosition(runtimeScene, object, operator, dimension, targetPosition);",
            "        }, startIndex, endIndex);",
            "    }",
            "}",
            "",
            "function changeMeshesPositionInRange(runtimeScene, meshName, startIdx, endIdx, operator, dimension, targetPosition) {",
            "    sceneTraverse(runtimeScene, meshName, (object) => {",
            "        changeMeshInstancePosition(runtimeScene, object, startIdx, endIdx, operator, dimension, targetPosition);",
            "    });",
            "}",
            "",
            "function sceneTraverse(runtimeScene, meshName, callback, startIdx = 0, endIdx = Number.MAX_SAFE_INTEGER) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    let currentIdx = 0;",
            "",
            "    threeScene.traverse(function (object) {",
            "        if (object.isMesh && object.name === meshName) {",
            "            if (currentIdx >= startIdx && currentIdx <= endIdx) {",
            "                callback(object);",
            "            }",
            "            currentIdx++;",
            "        }",
            "    });",
            "}",
            "",
            "const objectMesh = objects[0].getName();",
            "const startIndex = parseInt(eventsFunctionContext.getArgument(\"startIndex\"), 10);",
            "const endIndex = parseInt(eventsFunctionContext.getArgument(\"endIndex\"), 10);",
            "const targetPosition = parseFloat(eventsFunctionContext.getArgument(\"position\"));",
            "const operator = eventsFunctionContext.getArgument(\"operator\");",
            "const dimension = eventsFunctionContext.getArgument(\"axis\").toLowerCase();",
            "",
            "changeMeshesPositionInRange(runtimeScene, objectMesh, startIndex, endIndex, operator, dimension, targetPosition);",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the object",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "axis",
          "name": "axis",
          "supplementaryInformation": "[\"x\",\"y\",\"z\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Operator",
          "name": "operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "startIndex",
          "name": "startIndex",
          "type": "expression"
        },
        {
          "description": "endIndex",
          "name": "endIndex",
          "type": "expression"
        },
        {
          "description": "Position",
          "name": "position",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Set rotation of Instances",
      "fullName": "Set rotation of Instances",
      "functionType": "Action",
      "group": "Instances by index",
      "name": "SetRotation",
      "sentence": "Rotate instances of : _PARAM1_  Axis: _PARAM2_ Operator: _PARAM3_  From: _PARAM4_  To: _PARAM5_  Value: _PARAM6_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function rotateMeshInstancesWithOperator(runtimeScene, meshName, rotationAmount, startIndex, endIndex, operator, axis) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const mesh = threeScene.getObjectByName(meshName);",
            "",
            "    if (!mesh) {",
            "        return;",
            "    }",
            "",
            "    const rotationChange = THREE.MathUtils.degToRad(rotationAmount);",
            "",
            "    const rotateSingleMesh = (m, axis, rotationChange, operator) => {",
            "        if (operator === '=') {",
            "            m.rotation[axis] = rotationChange;",
            "        } else if (operator === '+') {",
            "            m.rotation[axis] += rotationChange;",
            "        } else if (operator === '-') {",
            "            m.rotation[axis] -= rotationChange;",
            "        }",
            "        m.updateMatrix();",
            "        m.updateMatrixWorld();",
            "    }",
            "",
            "    if (mesh.isInstancedMesh) {",
            "        for (let i = startIndex; i <= endIndex; i++) {",
            "            const matrix = new THREE.Matrix4();",
            "            mesh.getMatrixAt(i, matrix);",
            "            const position = new THREE.Vector3();",
            "            const quaternion = new THREE.Quaternion();",
            "            const scale = new THREE.Vector3();",
            "            matrix.decompose(position, quaternion, scale);",
            "",
            "            const axisVector = new THREE.Vector3(axis === 'x' ? 1 : 0, axis === 'y' ? 1 : 0, axis === 'z' ? 1 : 0);",
            "            rotateQuaternion(operator, quaternion, rotationChange, axisVector);",
            "",
            "            matrix.compose(position, quaternion, scale);",
            "            mesh.setMatrixAt(i, matrix);",
            "        }",
            "        mesh.instanceMatrix.needsUpdate = true;",
            "",
            "    } else {",
            "        const meshes = (Array.isArray(mesh.children) && mesh.children.length > 0) ? [mesh, ...mesh.children] : [mesh];",
            "        meshes.forEach((m, index) => {",
            "            if (index >= startIndex && index <= endIndex) {",
            "                rotateSingleMesh(m, axis, rotationChange, operator);",
            "            }",
            "        });",
            "    }",
            "    mesh.updateMatrixWorld();",
            "}",
            "",
            "function rotateQuaternion(operator, quaternion, rotationChange, axisVector) {",
            "    if (operator === '=') {",
            "        const euler = new THREE.Euler();",
            "        euler.setFromQuaternion(quaternion);",
            "        if(axisVector.x) euler.x = rotationChange;",
            "        if(axisVector.y) euler.y = rotationChange;",
            "        if(axisVector.z) euler.z = rotationChange;",
            "        quaternion.setFromEuler(euler);",
            "    } else if (operator === '+' || operator === '-') {",
            "        const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(axisVector, (operator === '+') ? rotationChange : -rotationChange);",
            "        quaternion.multiply(rotationQuaternion);",
            "    }",
            "}",
            "",
            "if (objects.length > 0) {",
            "    let objectMesh = objects[0];",
            "    let rotationAmount = eventsFunctionContext.getArgument(\"rotation\");",
            "    let operator = eventsFunctionContext.getArgument(\"operator\");",
            "    let axis = eventsFunctionContext.getArgument(\"axis\").toLowerCase();",
            "    let startIndex = parseInt(eventsFunctionContext.getArgument(\"startIndex\"), 10);",
            "    let endIndex = parseInt(eventsFunctionContext.getArgument(\"endIndex\"), 10);",
            "",
            "    rotateMeshInstancesWithOperator(runtimeScene, objectMesh.getName(), rotationAmount, startIndex, endIndex, operator, axis);",
            "}",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the InstancedMesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Axis",
          "name": "axis",
          "supplementaryInformation": "[\"x\",\"y\",\"z\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Operator",
          "name": "operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Start Index",
          "name": "startIndex",
          "type": "expression"
        },
        {
          "description": "End Index",
          "name": "endIndex",
          "type": "expression"
        },
        {
          "description": "Value",
          "name": "rotation",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Opacity of Instances  (if transparent = true)",
      "fullName": "Opacity of Instances",
      "functionType": "Action",
      "name": "SetOpacity",
      "sentence": "Opacity of instances of : _PARAM1_  Operator: _PARAM2_  Opacity: _PARAM3_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function changeInstancedMeshOpacity(runtimeScene, meshName, newOpacity, operator,transparent) {",
            "    var scene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "",
            "    function changeOpacity(instancedMesh) {",
            "        if (instancedMesh.material && 'opacity' in instancedMesh.material) {",
            "            var currentOpacity = instancedMesh.material.opacity;",
            "",
            "            switch (operator) {",
            "                case '=':",
            "                    currentOpacity = newOpacity;",
            "                    break;",
            "                case '+':",
            "                    currentOpacity = Math.min(currentOpacity + newOpacity, 1);",
            "                    break;",
            "                case '-':",
            "                    currentOpacity = Math.max(currentOpacity - newOpacity, 0);",
            "                    break;",
            "                default:",
            "                    return;",
            "            }",
            "",
            "            currentOpacity = Math.max(Math.min(currentOpacity, 1), 0);",
            "",
            "            instancedMesh.material.opacity = currentOpacity;",
            "            instancedMesh.material.needsUpdate = true;",
            "        }",
            "    }",
            "        var instancedMesh = scene.getObjectByName(meshName);",
            "",
            "        if (instancedMesh) {",
            "            changeOpacity(instancedMesh);",
            "        }",
            "    ",
            "}",
            "",
            "",
            "let objectMesh;",
            "",
            "if (objects.length > 0) {",
            "    objectMesh = objects[0];",
            "    changeInstancedMeshOpacity(runtimeScene, objectMesh.getName(), eventsFunctionContext.getArgument(\"opacity\"), eventsFunctionContext.getArgument(\"operator\")); ",
            "} "
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the Instanced Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Operator",
          "name": "operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Opacity (if transparent = true)",
          "name": "opacity",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Set scaling of Instances",
      "fullName": "Set scaling of Instances",
      "functionType": "Action",
      "group": "Instances by index",
      "name": "SetScaleInstances",
      "sentence": "Scale instances of : _PARAM1_   Axis: _PARAM2_ Operator: _PARAM3_  From: _PARAM4_  To: _PARAM5_ Value: _PARAM6_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function changeMeshInstancesScalingWithOperator(runtimeScene, meshName, targetScale, startIndex, endIndex, operator, dimension) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const mesh = threeScene.getObjectByName(meshName);",
            "",
            "    if (!mesh) {",
            "        return;",
            "    }",
            "",
            "    const MIN_SCALE = 0.01;",
            "",
            "    if (!mesh.isInstancedMesh) {",
            "        endIndex = Math.min(endIndex, (mesh.children.length > 0 ? mesh.children.length : 1) - 1);",
            "    } else {",
            "        endIndex = Math.min(endIndex, mesh.count - 1);",
            "    }",
            "",
            "    const applyScaling = (scale, targetScale, operator, dimension) => {",
            "        let newScale = scale[dimension];",
            "        if (operator === '=') {",
            "            newScale = targetScale;",
            "        } else if (operator === '+') {",
            "            newScale = scale[dimension] + targetScale;",
            "        } else if (operator === '-') {",
            "            newScale = Math.max(MIN_SCALE, scale[dimension] - targetScale);",
            "        }",
            "        return newScale;",
            "    };",
            "",
            "    if (mesh.isInstancedMesh) {",
            "        for (let i = startIndex; i <= endIndex; i++) {",
            "            const matrix = new THREE.Matrix4();",
            "            mesh.getMatrixAt(i, matrix);",
            "",
            "            const position = new THREE.Vector3();",
            "            const quaternion = new THREE.Quaternion();",
            "            const scale = new THREE.Vector3();",
            "            matrix.decompose(position, quaternion, scale);",
            "",
            "            scale[dimension] = applyScaling(scale, targetScale, operator, dimension);",
            "",
            "            matrix.compose(position, quaternion, scale);",
            "            mesh.setMatrixAt(i, matrix);",
            "        }",
            "        mesh.instanceMatrix.needsUpdate = true;",
            "",
            "    } else {",
            "        const meshes = (mesh.children.length > 0 ? [mesh].concat(mesh.children) : [mesh]);",
            "        meshes.forEach((m, index) => {",
            "            if (index >= startIndex && index <= endIndex) {",
            "                m.scale[dimension] = applyScaling(m.scale, targetScale, operator, dimension);",
            "                m.updateMatrix();",
            "            }",
            "        });",
            "",
            "        mesh.traverse(function (child) {",
            "            if (child.isBone) {",
            "                const parentScale = child.parent ? child.parent.scale[dimension] : 1;",
            "                child.scale[dimension] = applyScaling({ x: parentScale, y: parentScale, z: parentScale }, targetScale, operator, dimension);",
            "                child.updateMatrix();",
            "            }",
            "        });",
            "    }",
            "    mesh.updateMatrixWorld();",
            "}",
            "",
            "if (objects.length > 0) {",
            "    let objectMesh = objects[0];",
            "    let targetScale = parseFloat(eventsFunctionContext.getArgument(\"scale\"));",
            "    let operator = eventsFunctionContext.getArgument(\"operator\");",
            "    let dimension = eventsFunctionContext.getArgument(\"axis\").toLowerCase();",
            "    let startIndex = parseInt(eventsFunctionContext.getArgument(\"startIndex\"), 10);",
            "    let endIndex = parseInt(eventsFunctionContext.getArgument(\"endIndex\"), 10);",
            "",
            "    changeMeshInstancesScalingWithOperator(runtimeScene, objectMesh.getName(), targetScale, startIndex, endIndex, operator, dimension);",
            "}",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the InstancedMesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Axis",
          "name": "axis",
          "supplementaryInformation": "[\"x\",\"y\",\"z\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Operator",
          "name": "operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Start Index",
          "name": "startIndex",
          "type": "expression"
        },
        {
          "description": "End Index",
          "name": "endIndex",
          "type": "expression"
        },
        {
          "description": "Value",
          "name": "scale",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Set size of Instances",
      "fullName": "Set size of Instances",
      "functionType": "Action",
      "group": "Instances by index",
      "name": "SetSize",
      "sentence": "Set size of Instances: _PARAM1_   Axis: _PARAM2_ Operator: _PARAM3_  From Index:_PARAM4_ To Index:  _PARAM5_ Size: _PARAM6_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getInstancedMeshInstanceDimensions(runtimeScene, instancedMeshName, instanceIndex) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const instancedMesh = threeScene.getObjectByName(instancedMeshName);",
            "    const dimensions = { width: 0, height: 0, depth: 0 };",
            "",
            "    if (instancedMesh && instancedMesh.isInstancedMesh) {",
            "        instancedMesh.geometry.computeBoundingBox();",
            "        const boundingBox = instancedMesh.geometry.boundingBox.clone();",
            "        ",
            "        const matrix = new THREE.Matrix4();",
            "        instancedMesh.getMatrixAt(instanceIndex, matrix);",
            "",
            "        boundingBox.applyMatrix4(matrix);",
            "",
            "        dimensions.width = boundingBox.max.x - boundingBox.min.x;",
            "        dimensions.height = boundingBox.max.y - boundingBox.min.y;",
            "        dimensions.depth = boundingBox.max.z - boundingBox.min.z;",
            "    }",
            "",
            "    return dimensions;",
            "}",
            "",
            "function changeInstancedMeshInstancesScalingWithOperator(runtimeScene, meshName, targetSize, startIndex, endIndex, operator, dimension) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const instancedMesh = threeScene.getObjectByName(meshName);",
            "    const MIN_SIZE = 1;",
            "",
            "    if (!instancedMesh) {",
            "        return;",
            "    }",
            "",
            "    startIndex = Math.max(0, startIndex);",
            "    endIndex = Math.min(endIndex, instancedMesh.count - 1);",
            "",
            "    for (let i = startIndex; i <= endIndex; i++) {",
            "        const matrix = new THREE.Matrix4();",
            "        instancedMesh.getMatrixAt(i, matrix);",
            "",
            "        const position = new THREE.Vector3();",
            "        const quaternion = new THREE.Quaternion();",
            "        const scale = new THREE.Vector3();",
            "        matrix.decompose(position, quaternion, scale);",
            "",
            "        const currentDimensions = getInstancedMeshInstanceDimensions(runtimeScene, meshName, i);",
            "        const currentSize = currentDimensions[dimension === 'x' ? 'width' : dimension === 'y' ? 'height' : 'depth'];",
            "",
            "        let scaleFactor = 1; ",
            "        let dimensionSize = dimension === 'x' ? 'width' : dimension === 'y' ? 'height' : 'depth';",
            "",
            "        if (operator === '=') {",
            "            scaleFactor = targetSize / currentSize;",
            "        } else if (operator === '+') {",
            "            scaleFactor = (currentSize + targetSize) / currentSize;",
            "        } else if (operator === '-') {",
            "            let newSize = Math.max(currentSize - targetSize, MIN_SIZE);",
            "            scaleFactor = newSize / currentSize;",
            "        }",
            "",
            "        scale[dimension] *= scaleFactor;",
            "        matrix.compose(position, quaternion, scale);",
            "        instancedMesh.setMatrixAt(i, matrix);",
            "    }",
            "",
            "    instancedMesh.instanceMatrix.needsUpdate = true;",
            "}",
            "",
            "function resizeMeshesInRange(runtimeScene, baseName, startIdx, endIdx, operator, dimension, targetSize) {",
            "    const MIN_SIZE = 1;",
            "",
            "    var threeScene = runtimeScene.getLayer(\"\").getRenderer().getThreeScene();",
            "    ",
            "    var currentIdx = 0;",
            "",
            "    threeScene.traverse(function (object) {",
            "        if (object.isMesh && object.name === baseName) {",
            "            ",
            "            if (object.isInstancedMesh) {",
            "                changeInstancedMeshInstancesScalingWithOperator(runtimeScene, baseName, targetSize, startIdx, endIdx, operator, dimension);",
            "            } else {",
            "                if (currentIdx >= startIdx && currentIdx <= endIdx) {",
            "                    var mesh = object;",
            "                    var isSkinnedMesh = mesh.isSkinnedMesh;",
            "",
            "                    var boundingBox = new THREE.Box3().setFromObject(mesh);",
            "                    ",
            "",
            "                    var size = new THREE.Vector3();",
            "                    boundingBox.getSize(size);",
            "                    ",
            "",
            "                    var newSizeX = size.x;",
            "                    var newSizeY = size.y;",
            "                    var newSizeZ = size.z;",
            "",
            "                    let scalingFactors = {",
            "                        x: 1,",
            "                        y: 1,",
            "                        z: 1",
            "                    };",
            "",
            "                    switch (dimension) {",
            "                        case 'x':",
            "                            if (operator === '+') {",
            "                                newSizeX = size.x + targetSize;",
            "                            } else if (operator === '-') {",
            "                                newSizeX = Math.max(size.x - targetSize, MIN_SIZE);",
            "                            } else if (operator === '=' && size.x !== targetSize) {",
            "                                newSizeX = targetSize;",
            "                            }",
            "                            scalingFactors.x = newSizeX / size.x;",
            "                            break;",
            "                        case 'y':",
            "                            if (operator === '+') {",
            "                                newSizeY = size.y + targetSize;",
            "                            } else if (operator === '-') {",
            "                                newSizeY = Math.max(size.y - targetSize, MIN_SIZE);",
            "                            } else if (operator === '=' && size.y !== targetSize) {",
            "                                newSizeY = targetSize;",
            "                            }",
            "                            scalingFactors.y = newSizeY / size.y;",
            "                            break;",
            "                        case 'z':",
            "                            if (operator === '+') {",
            "                                newSizeZ = size.z + targetSize;",
            "                            } else if (operator === '-') {",
            "                                newSizeZ = Math.max(size.z - targetSize, MIN_SIZE);",
            "                            } else if (operator === '=' && size.z !== targetSize) {",
            "                                newSizeZ = targetSize;",
            "                            }",
            "                            scalingFactors.z = newSizeZ / size.z;",
            "                            break;",
            "                        default:",
            "                            return;",
            "                    }",
            "",
            "                    mesh.scale.set(",
            "                        mesh.scale.x * scalingFactors.x,",
            "                        mesh.scale.y * scalingFactors.y,",
            "                        mesh.scale.z * scalingFactors.z",
            "                    );",
            "",
            "                    if (isSkinnedMesh) {",
            "                        mesh.skeleton.bones.forEach(function(bone) {",
            "                            let boneScalingFactors = {",
            "                                x: bone.scale.x,",
            "                                y: bone.scale.y,",
            "                                z: bone.scale.z",
            "                            };",
            "                            switch (dimension) {",
            "                                case 'x':",
            "                                    boneScalingFactors.x = bone.scale.x * scalingFactors.x;",
            "                                    break;",
            "                                case 'y':",
            "                                    boneScalingFactors.y = bone.scale.y * scalingFactors.y;",
            "                                    break;",
            "                                case 'z':",
            "                                    boneScalingFactors.z = bone.scale.z * scalingFactors.z;",
            "                                    break;",
            "                            }",
            "",
            "                            bone.scale.set(",
            "                                boneScalingFactors.x,",
            "                                boneScalingFactors.y,",
            "                                boneScalingFactors.z",
            "                            );",
            "",
            "                        });",
            "                        mesh.skeleton.pose();",
            "                    }",
            "",
            "                    var newBoundingBox = new THREE.Box3().setFromObject(mesh);",
            "                    var newSizeVector = new THREE.Vector3();",
            "                    newBoundingBox.getSize(newSizeVector);",
            "                    ",
            "                }",
            "                currentIdx++;",
            "            }",
            "        }",
            "    });",
            "}",
            "",
            "const objectMesh = objects[0].getName();",
            "const startIndex = parseInt(eventsFunctionContext.getArgument(\"startIndex\"), 10);",
            "const endIndex = parseInt(eventsFunctionContext.getArgument(\"endIndex\"), 10);",
            "const targetSize = parseFloat(eventsFunctionContext.getArgument(\"size\"));",
            "const operator = eventsFunctionContext.getArgument(\"operator\");",
            "const dimension = eventsFunctionContext.getArgument(\"axis\").toLowerCase();",
            "",
            "resizeMeshesInRange(runtimeScene, objectMesh, startIndex, endIndex, operator, dimension, targetSize);"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Axis",
          "name": "axis",
          "supplementaryInformation": "[\"x\",\"y\",\"z\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Operator",
          "name": "operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Start Index",
          "name": "startIndex",
          "type": "expression"
        },
        {
          "description": "End Index",
          "name": "endIndex",
          "type": "expression"
        },
        {
          "description": "Size",
          "name": "size",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Transparent",
      "fullName": "Transparent",
      "functionType": "Action",
      "name": "SetTransparentBoolean",
      "sentence": "Transparency of: _PARAM1_ is _PARAM2_  ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function changeInstancedMeshOpacity(runtimeScene, meshName,transparent) {",
            "    var scene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "",
            "    function changeOpacity(instancedMesh) {",
            "        if (instancedMesh.material && 'opacity' in instancedMesh.material) {",
            "            ",
            "            instancedMesh.material.needsUpdate = true;",
            "        }",
            "    }",
            "        var instancedMesh = scene.getObjectByName(meshName);",
            "        if (transparent) {",
            "        if (instancedMesh) {",
            "            instancedMesh.material.transparent = transparent;",
            "        }",
            "    }",
            "}",
            "",
            "",
            "let objectMesh;",
            "",
            "if (objects.length > 0) {",
            "    objectMesh = objects[0];",
            "    changeInstancedMeshOpacity(runtimeScene, objectMesh.getName(),eventsFunctionContext.getArgument(\"transparent\")); ",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the Instanced Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Transparent",
          "name": "transparent",
          "type": "trueorfalse"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Put instances around a point",
      "fullName": "Put instances around a point",
      "functionType": "Action",
      "getterName": "IsScaleOfInstance",
      "group": "Instances by index",
      "name": "PutInstancesAroundPoint",
      "sentence": "Put instances of: _PARAM1_  From _PARAM2_  To _PARAM3_ PointX: _PARAM4_ PointY: _PARAM5_ PointZ: _PARAM6_ H_Angle: _PARAM7_ V_Angle: _PARAM8_ Distance: _PARAM9_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function setMeshPositionByAnglesAndDistance(runtimeScene, meshName, startIndex, endIndex, horizontalAngleDeg, verticalAngleDeg, distance, centerPoint) {",
            "    const objects = runtimeScene.getObjects(meshName);",
            "",
            "    if (!objects || objects.length === 0) {",
            "        return;",
            "    }",
            "",
            "    startIndex = Math.max(0, startIndex);",
            "    endIndex = Math.min(endIndex, objects.length - 1);",
            "",
            "    const horizontalAngleRad = THREE.MathUtils.degToRad(horizontalAngleDeg);",
            "    const verticalAngleRad = THREE.MathUtils.degToRad(verticalAngleDeg);",
            "",
            "    for (let i = startIndex; i <= endIndex; i++) {",
            "        const obj = objects[i];",
            "",
            "        const newX = centerPoint.x + distance * Math.cos(horizontalAngleRad) * Math.cos(verticalAngleRad);",
            "        const newY = centerPoint.y + distance * Math.sin(horizontalAngleRad) * Math.cos(verticalAngleRad);",
            "        const newZ = centerPoint.z - distance * Math.sin(verticalAngleRad);",
            "",
            "        obj.setX(newX);",
            "        obj.setY(newY);",
            "        obj.setZ(newZ);",
            "    }",
            "}",
            "",
            "",
            "if (objects.length > 0) {",
            "    let objectMesh = objects[0];",
            "    const horizontalAngleDeg = parseFloat(eventsFunctionContext.getArgument(\"horizontalAngle\")); ",
            "    const verticalAngleDeg = parseFloat(eventsFunctionContext.getArgument(\"verticalAngle\")); ",
            "    const distance = parseFloat(eventsFunctionContext.getArgument(\"distance\"));",
            "    const centerPoint = new THREE.Vector3(",
            "        parseFloat(eventsFunctionContext.getArgument(\"centerPointX\")),",
            "        parseFloat(eventsFunctionContext.getArgument(\"centerPointY\")),",
            "        parseFloat(eventsFunctionContext.getArgument(\"centerPointZ\"))",
            "    ); ",
            "    const startIndex = parseInt(eventsFunctionContext.getArgument(\"startIndex\"), 10); ",
            "    const endIndex = parseInt(eventsFunctionContext.getArgument(\"endIndex\"), 10); ",
            "",
            "",
            "",
            "setMeshPositionByAnglesAndDistance(runtimeScene, objectMesh.getName(), startIndex, endIndex, horizontalAngleDeg, verticalAngleDeg, distance, centerPoint);",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        },
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function setInstancedMeshInstancesPositionByAnglesAndDistance(runtimeScene, meshName, startIndex, endIndex, horizontalAngleDeg, verticalAngleDeg, distance, centerPoint) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const mesh = threeScene.getObjectByName(meshName);",
            "",
            "    if (!mesh) {",
            "        return;",
            "    }",
            "",
            "    startIndex = Math.max(0, startIndex);",
            "    endIndex = Math.min(endIndex, mesh.count - 1);",
            "",
            "    const horizontalAngleRad = THREE.MathUtils.degToRad(horizontalAngleDeg);",
            "    const verticalAngleRad = THREE.MathUtils.degToRad(verticalAngleDeg);",
            "",
            "    for (let i = startIndex; i <= endIndex; i++) {",
            "        const matrix = new THREE.Matrix4();",
            "        mesh.getMatrixAt(i, matrix);",
            "",
            "        const position = new THREE.Vector3();",
            "        const quaternion = new THREE.Quaternion();",
            "        const scale = new THREE.Vector3();",
            "        matrix.decompose(position, quaternion, scale);",
            "",
            "",
            "        position.x = centerPoint.x + distance * Math.cos(horizontalAngleRad) * Math.cos(verticalAngleRad);",
            "        position.y = centerPoint.y + distance * Math.sin(horizontalAngleRad) * Math.cos(verticalAngleRad);",
            "        position.z = centerPoint.z - distance * Math.sin(verticalAngleRad);",
            "",
            "        matrix.compose(position, quaternion, scale);",
            "        mesh.setMatrixAt(i, matrix);",
            "    }",
            "",
            "    mesh.instanceMatrix.needsUpdate = true;",
            "}",
            "",
            "",
            "if (objects.length > 0) {",
            "    let objectMesh = objects[0];",
            "    const horizontalAngleDeg = parseFloat(eventsFunctionContext.getArgument(\"horizontalAngle\")); ",
            "    const verticalAngleDeg = parseFloat(eventsFunctionContext.getArgument(\"verticalAngle\")); ",
            "    const distance = parseFloat(eventsFunctionContext.getArgument(\"distance\"));",
            "    const centerPoint = new THREE.Vector3(",
            "        parseFloat(eventsFunctionContext.getArgument(\"centerPointX\")),",
            "        parseFloat(eventsFunctionContext.getArgument(\"centerPointY\")),",
            "        parseFloat(eventsFunctionContext.getArgument(\"centerPointZ\"))",
            "    ); ",
            "    const startIndex = parseInt(eventsFunctionContext.getArgument(\"startIndex\"), 10); ",
            "    const endIndex = parseInt(eventsFunctionContext.getArgument(\"endIndex\"), 10); ",
            "",
            "",
            "",
            "setInstancedMeshInstancesPositionByAnglesAndDistance(runtimeScene, objectMesh.getName(), startIndex, endIndex, horizontalAngleDeg, verticalAngleDeg, distance, centerPoint);",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the object",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Mode",
          "name": "mode",
          "supplementaryInformation": "[\"Instanced mesh\",\"Normal mesh\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "startIndex",
          "name": "startIndex",
          "type": "expression"
        },
        {
          "description": "endIndex",
          "name": "endIndex",
          "type": "expression"
        },
        {
          "description": "PointX",
          "name": "centerPointX",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "expression"
        },
        {
          "description": "PointY",
          "name": "centerPointY",
          "supplementaryInformation": "[\"x\",\"y\",\"z\"]",
          "type": "expression"
        },
        {
          "description": "PointZ",
          "name": "centerPointZ",
          "type": "expression"
        },
        {
          "description": "horizontalAngle",
          "name": "horizontalAngle",
          "type": "expression"
        },
        {
          "description": "verticalAngle",
          "name": "verticalAngle",
          "type": "expression"
        },
        {
          "description": "distance",
          "name": "distance",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Change material of the mesh",
      "fullName": "Change material of the mesh",
      "functionType": "Action",
      "name": "ChangeMaterial",
      "sentence": "Change material of the mesh: _PARAM1_ to _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            switch (eventsFunctionContext.getArgument(\"materialType\")) {",
            "                case 'MeshBasicMaterial':",
            "                    node.material = new THREE.MeshBasicMaterial();",
            "                    break;",
            "                case 'MeshLambertMaterial':",
            "                    node.material = new THREE.MeshLambertMaterial();",
            "                    break;",
            "                case 'MeshMatcapMaterial':",
            "                    node.material = new THREE.MeshMatcapMaterial();",
            "                    break;",
            "                case 'MeshPhongMaterial':",
            "                    node.material = new THREE.MeshPhongMaterial();",
            "                    break;",
            "                case 'MeshToonMaterial':",
            "                    node.material = new THREE.MeshToonMaterial();",
            "                    break;",
            "                case 'MeshStandardMaterial':",
            "                    node.material = new THREE.MeshStandardMaterial();",
            "                    break;",
            "                case 'MeshNormalMaterial':",
            "                    node.material = new THREE.MeshNormalMaterial();",
            "                    break;",
            "                case 'MeshPhysicalMaterial':",
            "                    node.material = new THREE.MeshPhysicalMaterial();",
            "                    break;",
            "                default:",
            "                    console.warn('Invalid or no material type was given for action: change material type, object name: ' + objects[0].getName());",
            "            }",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Material type",
          "name": "materialType",
          "supplementaryInformation": "[\"MeshStandardMaterial\",\"MeshBasicMaterial\",\"MeshPhysicalMaterial\",\"MeshLambertMaterial\",\"MeshPhongMaterial\",\"MeshToonMaterial\",\"MeshMatcapMaterial\",\"MeshNormalMaterial\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Alpha Map",
      "fullName": "Alpha Map",
      "functionType": "Action",
      "group": "Maps",
      "name": "AlphaMap",
      "sentence": "Alpha Map of: _PARAM1_  Source: _PARAM2_  FlipY: _PARAM3_ RepeatX: _PARAM4_  RepeatY: _PARAM5_  OffsetX: _PARAM6_  OffsetY: _PARAM7_  Rotation: _PARAM8_ CenterX: _PARAM9_ CenterY: _PARAM10_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            if (node.material.alphaMap !== undefined) {",
            "                if (node.material.alphaMap instanceof THREE.Texture) {",
            "                    node.material.alphaMap.dispose();",
            "                }",
            "                var textureLoader = new THREE.TextureLoader();",
            "                let textureMapName = eventsFunctionContext.getArgument(\"source\");",
            "                let flip = eventsFunctionContext.getArgument(\"flip\");",
            "                let xRepeat = eventsFunctionContext.getArgument(\"xRepeat\");",
            "                let yRepeat = eventsFunctionContext.getArgument(\"yRepeat\");",
            "                let xOffset = eventsFunctionContext.getArgument(\"xOffset\");",
            "                let yOffset = eventsFunctionContext.getArgument(\"yOffset\");",
            "                let rotation = eventsFunctionContext.getArgument(\"rotation\");",
            "                let centerX = eventsFunctionContext.getArgument(\"centerX\");",
            "                let centerY = eventsFunctionContext.getArgument(\"centerY\");",
            "                var texture = textureLoader.load(textureMapName.substring(textureMapName.lastIndexOf('\\\\') + 1));",
            "                if (flip) {",
            "                    texture.flipY = true;",
            "                } ",
            "                texture.repeat.set(xRepeat, yRepeat);",
            "                texture.offset.set(xOffset, yOffset);",
            "                texture.rotation = rotation;",
            "                texture.center.set(centerX, centerY);",
            "                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;",
            "                node.material.alphaMap = texture;",
            "                node.material.needsUpdate = true;",
            "                ",
            "            } else {",
            "                console.log('Texture map property does not exist for this material type: ' + node.material.type + ', object name: ' + objects[0].getName());",
            "            }",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of the InstancedMesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "source",
          "longDescription": "source",
          "name": "source",
          "type": "imageResource"
        },
        {
          "description": "Flip the texture Y",
          "name": "flip",
          "type": "trueorfalse"
        },
        {
          "description": "xRepeat",
          "name": "xRepeat",
          "type": "expression"
        },
        {
          "description": "yRepeat",
          "name": "yRepeat",
          "type": "expression"
        },
        {
          "description": "xOffset",
          "name": "xOffset",
          "type": "expression"
        },
        {
          "description": "yOffset",
          "name": "yOffset",
          "type": "expression"
        },
        {
          "description": "Rotation",
          "name": "rotation",
          "type": "expression"
        },
        {
          "description": "Rotation centerX",
          "name": "centerX",
          "type": "expression"
        },
        {
          "description": "Rotation centerY",
          "name": "centerY",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Anisotropy",
      "fullName": "Anisotropy",
      "functionType": "Action",
      "group": "Maps",
      "name": "Anisotropy",
      "sentence": "Anisotropy: _PARAM1_ Value: _PARAM2_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            let anisotropy = eventsFunctionContext.getArgument(\"anisotropy\");",
            "            node.material.anisotropy = anisotropy;",
            "            node.material.needsUpdate = true;",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Anisotropy",
          "name": "anisotropy",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Anisotropy rotation",
      "fullName": "Anisotropy rotation",
      "functionType": "Action",
      "group": "Maps",
      "name": "AnisotropyRotation",
      "sentence": "Anisotropy rotation of: _PARAM1_ Value: _PARAM2_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            let anisotropyRotation  = eventsFunctionContext.getArgument(\"anisotropyRotation\");",
            "            node.material.anisotropyRotation = anisotropyRotation;",
            "            node.material.needsUpdate = true;",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Anisotropy Rotation",
          "name": "anisotropyRotation",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Anisotropy Map",
      "fullName": "Anisotropy Map",
      "functionType": "Action",
      "group": "Maps",
      "name": "AnisotropyMap",
      "sentence": "Anisotropy Map of: _PARAM1_  Source: _PARAM2_  FlipY: _PARAM3_ RepeatX: _PARAM4_  RepeatY: _PARAM5_  OffsetX: _PARAM6_  OffsetY: _PARAM7_  Rotation: _PARAM8_ CenterX: _PARAM9_ CenterY: _PARAM10_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            if (node.material.hasOwnProperty('anisotropyMap')) {",
            "                if (node.material.aoMap instanceof THREE.Texture) {",
            "                    node.material.aoMap.dispose();",
            "                }",
            "                var textureLoader = new THREE.TextureLoader();",
            "                let textureMapName = eventsFunctionContext.getArgument(\"source\");",
            "                let flip = eventsFunctionContext.getArgument(\"flip\");",
            "                let xRepeat = eventsFunctionContext.getArgument(\"xRepeat\");",
            "                let yRepeat = eventsFunctionContext.getArgument(\"yRepeat\");",
            "                let xOffset = eventsFunctionContext.getArgument(\"xOffset\");",
            "                let yOffset = eventsFunctionContext.getArgument(\"yOffset\");",
            "                let rotation = eventsFunctionContext.getArgument(\"rotation\");",
            "                let centerX = eventsFunctionContext.getArgument(\"centerX\");",
            "                let centerY = eventsFunctionContext.getArgument(\"centerY\");",
            "                var texture = textureLoader.load(textureMapName.substring(textureMapName.lastIndexOf('\\\\') + 1));",
            "                if (flip) {",
            "                    texture.flipY = true;",
            "                } ",
            "                texture.repeat.set(xRepeat, yRepeat);",
            "                texture.offset.set(xOffset, yOffset);",
            "                texture.rotation = rotation;",
            "                texture.center.set(centerX, centerY);",
            "                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;",
            "                node.material.anisotropyMap = texture;",
            "                node.material.needsUpdate = true;",
            "                ",
            "            } else {",
            "                console.warn('Texture map property does not exist for this material type: ' + node.material.type + ', object name: ' + objects[0].getName());",
            "            }",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of the InstancedMesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "source",
          "longDescription": "source",
          "name": "source",
          "type": "imageResource"
        },
        {
          "description": "Flip the texture Y",
          "name": "flip",
          "type": "trueorfalse"
        },
        {
          "description": "xRepeat",
          "name": "xRepeat",
          "type": "expression"
        },
        {
          "description": "yRepeat",
          "name": "yRepeat",
          "type": "expression"
        },
        {
          "description": "xOffset",
          "name": "xOffset",
          "type": "expression"
        },
        {
          "description": "yOffset",
          "name": "yOffset",
          "type": "expression"
        },
        {
          "description": "Rotation",
          "name": "rotation",
          "type": "expression"
        },
        {
          "description": "Rotation centerX",
          "name": "centerX",
          "type": "expression"
        },
        {
          "description": "Rotation centerY",
          "name": "centerY",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "AoMap (ambient occlusion)",
      "fullName": "AoMap",
      "functionType": "Action",
      "group": "Maps",
      "name": "AOmap",
      "sentence": "AO Map of: _PARAM1_  Source: _PARAM2_  FlipY: _PARAM3_ RepeatX: _PARAM4_  RepeatY: _PARAM5_  OffsetX: _PARAM6_  OffsetY: _PARAM7_  Rotation: _PARAM8_ CenterX: _PARAM9_ CenterY: _PARAM10_ Value: _PARAM11_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            if (node.material.hasOwnProperty('aoMap')) {",
            "                if (node.material.aoMap instanceof THREE.Texture) {",
            "                    node.material.aoMap.dispose();",
            "                }",
            "                var textureLoader = new THREE.TextureLoader();",
            "                let textureMapName = eventsFunctionContext.getArgument(\"source\");",
            "                let flip = eventsFunctionContext.getArgument(\"flip\");",
            "                let xRepeat = eventsFunctionContext.getArgument(\"xRepeat\");",
            "                let yRepeat = eventsFunctionContext.getArgument(\"yRepeat\");",
            "                let xOffset = eventsFunctionContext.getArgument(\"xOffset\");",
            "                let yOffset = eventsFunctionContext.getArgument(\"yOffset\");",
            "                let rotation = eventsFunctionContext.getArgument(\"rotation\");",
            "                let centerX = eventsFunctionContext.getArgument(\"centerX\");",
            "                let centerY = eventsFunctionContext.getArgument(\"centerY\");",
            "                let aoMapIntensity = eventsFunctionContext.getArgument(\"aoMapIntensity\");",
            "                var texture = textureLoader.load(textureMapName.substring(textureMapName.lastIndexOf('\\\\') + 1));",
            "                if (flip) {",
            "                    texture.flipY = true;",
            "                } ",
            "                texture.repeat.set(xRepeat, yRepeat);",
            "                texture.offset.set(xOffset, yOffset);",
            "                texture.rotation = rotation;",
            "                texture.center.set(centerX, centerY);",
            "                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;",
            "                node.material.aoMapIntensity = aoMapIntensity;",
            "                node.material.aoMap = texture;",
            "                node.material.needsUpdate = true;",
            "                ",
            "            } else {",
            "                console.warn('Texture map property does not exist for this material type: ' + node.material.type + ', object name: ' + objects[0].getName());",
            "            }",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the InstancedMesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "source",
          "longDescription": "source",
          "name": "source",
          "type": "imageResource"
        },
        {
          "description": "Flip the texture Y",
          "name": "flip",
          "type": "trueorfalse"
        },
        {
          "description": "xRepeat",
          "name": "xRepeat",
          "type": "expression"
        },
        {
          "description": "yRepeat",
          "name": "yRepeat",
          "type": "expression"
        },
        {
          "description": "xOffset",
          "name": "xOffset",
          "type": "expression"
        },
        {
          "description": "yOffset",
          "name": "yOffset",
          "type": "expression"
        },
        {
          "description": "Rotation",
          "name": "rotation",
          "type": "expression"
        },
        {
          "description": "Rotation centerX",
          "name": "centerX",
          "type": "expression"
        },
        {
          "description": "Rotation centerY",
          "name": "centerY",
          "type": "expression"
        },
        {
          "description": "Value",
          "name": "aoMapIntensity",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Attenuation color",
      "fullName": "Attenuation color",
      "functionType": "Action",
      "group": "Maps",
      "name": "AttenuationColor",
      "sentence": "Attenuation color of: _PARAM1_ Value: _PARAM2_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "  objects[0].get3DRendererObject().traverse((node) => {",
            "    if (node.isMesh && node.material.isMaterial) {",
            "      const rgbcolor = gdjs.rgbOrHexToRGBColor(eventsFunctionContext.getArgument(\"attenuationColor\"));",
            "      const hexColor = parseInt(\"0x\" + gdjs.rgbToHex(rgbcolor[0], rgbcolor[1], rgbcolor[2]), 16);",
            "",
            "      node.material.side = THREE.DoubleSide;",
            "      node.material.attenuationColor = new THREE.Color(hexColor);",
            "",
            "      node.material.needsUpdate = true;",
            "    }",
            "  });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "attenuationColor",
          "name": "attenuationColor",
          "type": "color"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Attenuation distance",
      "fullName": "Attenuation distance",
      "functionType": "Action",
      "group": "Maps",
      "name": "AttenuationDistance",
      "sentence": "Attenuation distance of: _PARAM1_ Value: _PARAM2_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            const attenuationDistance = (eventsFunctionContext.getArgument(\"attenuationDistance\"));",
            "            node.material.attenuationDistance = attenuationDistance;",
            "            node.material.needsUpdate = true;",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "attenuationDistance",
          "name": "attenuationDistance",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Clearcoat",
      "fullName": "Clearcoat",
      "functionType": "Action",
      "group": "Maps",
      "name": "Clearcoat",
      "sentence": "Clearcoat: _PARAM1_ Value: _PARAM2_ Roughness: _PARAM3_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            let clearcoatValue = eventsFunctionContext.getArgument(\"clearcoat\");",
            "            let clearcoatRoughnessValue  = eventsFunctionContext.getArgument(\"clearcoatRoughnessValue\");",
            "            node.material.clearcoat = clearcoatValue;",
            "            node.material.clearcoatRoughness = clearcoatRoughnessValue;",
            "            node.material.needsUpdate = true;",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Clearcoat",
          "longDescription": "Mesh Physical material is required for clearcoat",
          "name": "clearcoat",
          "type": "expression"
        },
        {
          "description": "clearcoatRoughnessValue",
          "name": "clearcoatRoughnessValue",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Dispersion",
      "fullName": "Dispersion",
      "functionType": "Action",
      "group": "Maps",
      "name": "Dispersion",
      "sentence": "Dispersion of: _PARAM1_ Dispersion value: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            node.material.dispersion = eventsFunctionContext.getArgument(\"dispersion\");",
            "            node.material.needsUpdate = true;",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Dispersion (0-1)",
          "longDescription": "Mesh Physical material is required for dispersion",
          "name": "dispersion",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Displacement Map",
      "fullName": "Displacement Map",
      "functionType": "Action",
      "group": "Maps",
      "name": "DisplacementMap",
      "sentence": "Displacement Map of: _PARAM1_  Source: _PARAM2_  FlipY: _PARAM3_ RepeatX: _PARAM4_  RepeatY: _PARAM5_  OffsetX: _PARAM6_  OffsetY: _PARAM7_  Rotation: _PARAM8_ CenterX: _PARAM9_ CenterY: _PARAM10_ Scale: _PARAM11_ Bias: _PARAM12_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            if (node.material.hasOwnProperty('displacementMap')) {",
            "                if (node.material.displacementMap instanceof THREE.Texture) {",
            "                    node.material.displacementMap.dispose();",
            "                }",
            "                var textureLoader = new THREE.TextureLoader();",
            "                let textureMapName = eventsFunctionContext.getArgument(\"source\");",
            "                let flip = eventsFunctionContext.getArgument(\"flip\");",
            "                let xRepeat = eventsFunctionContext.getArgument(\"xRepeat\");",
            "                let yRepeat = eventsFunctionContext.getArgument(\"yRepeat\");",
            "                let xOffset = eventsFunctionContext.getArgument(\"xOffset\");",
            "                let yOffset = eventsFunctionContext.getArgument(\"yOffset\");",
            "                let rotation = eventsFunctionContext.getArgument(\"rotation\");",
            "                let centerX = eventsFunctionContext.getArgument(\"centerX\");",
            "                let centerY = eventsFunctionContext.getArgument(\"centerY\");",
            "                let displacementScale = eventsFunctionContext.getArgument(\"displacementScale\");",
            "                let displacementBias = eventsFunctionContext.getArgument(\"displacementBias\");",
            "                var texture = textureLoader.load(textureMapName.substring(textureMapName.lastIndexOf('\\\\') + 1));",
            "                if (flip) {",
            "                    texture.flipY = true;",
            "                } ",
            "                texture.repeat.set(xRepeat, yRepeat);",
            "                texture.offset.set(xOffset, yOffset);",
            "                texture.rotation = rotation;",
            "                texture.center.set(centerX, centerY);",
            "                node.material.displacementScale = displacementScale;",
            "                node.material.displacementBias = displacementBias;",
            "                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;",
            "                node.material.displacementMap = texture;",
            "                node.material.needsUpdate = true;",
            "                ",
            "            } else {",
            "                console.warn('Texture map property does not exist for this material type: ' + node.material.type + ', object name: ' + objects[0].getName());",
            "            }",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the InstancedMesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "source",
          "longDescription": "source",
          "name": "source",
          "type": "imageResource"
        },
        {
          "description": "Flip the texture Y",
          "name": "flip",
          "type": "trueorfalse"
        },
        {
          "description": "xRepeat",
          "name": "xRepeat",
          "type": "expression"
        },
        {
          "description": "yRepeat",
          "name": "yRepeat",
          "type": "expression"
        },
        {
          "description": "xOffset",
          "name": "xOffset",
          "type": "expression"
        },
        {
          "description": "yOffset",
          "name": "yOffset",
          "type": "expression"
        },
        {
          "description": "Rotation",
          "name": "rotation",
          "type": "expression"
        },
        {
          "description": "Rotation centerX",
          "name": "centerX",
          "type": "expression"
        },
        {
          "description": "Rotation centerY",
          "name": "centerY",
          "type": "expression"
        },
        {
          "description": "displacementScale",
          "name": "displacementScale",
          "type": "expression"
        },
        {
          "description": "displacementBias",
          "name": "displacementBias",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Emissive Map",
      "fullName": "Emissive Map",
      "functionType": "Action",
      "group": "Maps",
      "name": "EmissiveMap",
      "sentence": "Emissive Map of: _PARAM1_  Source: _PARAM2_  FlipY: _PARAM3_ RepeatX: _PARAM4_  RepeatY: _PARAM5_  OffsetX: _PARAM6_  OffsetY: _PARAM7_  Rotation: _PARAM8_ CenterX: _PARAM9_ CenterY: _PARAM10_ Color: _PARAM11_ Level: _PARAM12_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            if (node.material.hasOwnProperty('emissiveMap')) {",
            "                if (node.material.emissiveMap instanceof THREE.Texture) {",
            "                    node.material.emissiveMap.dispose();",
            "                }",
            "                var textureLoader = new THREE.TextureLoader();",
            "                let textureMapName = eventsFunctionContext.getArgument(\"source\");",
            "                let flip = eventsFunctionContext.getArgument(\"flip\");",
            "                let xRepeat = eventsFunctionContext.getArgument(\"xRepeat\");",
            "                let yRepeat = eventsFunctionContext.getArgument(\"yRepeat\");",
            "                let xOffset = eventsFunctionContext.getArgument(\"xOffset\");",
            "                let yOffset = eventsFunctionContext.getArgument(\"yOffset\");",
            "                let rotation = eventsFunctionContext.getArgument(\"rotation\");",
            "                let centerX = eventsFunctionContext.getArgument(\"centerX\");",
            "                let centerY = eventsFunctionContext.getArgument(\"centerY\");",
            "                let emissiveColor = eventsFunctionContext.getArgument(\"emissiveColor\");",
            "                let emissiveIntensity = eventsFunctionContext.getArgument(\"emissiveIntensity\");",
            "                var texture = textureLoader.load(textureMapName.substring(textureMapName.lastIndexOf('\\\\') + 1));",
            "                if (flip) {",
            "                    texture.flipY = true;",
            "                } ",
            "                texture.repeat.set(xRepeat, yRepeat);",
            "                texture.offset.set(xOffset, yOffset);",
            "                texture.rotation = rotation;",
            "                texture.center.set(centerX, centerY);",
            "                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;",
            "                const rgbArray = gdjs.rgbOrHexToRGBColor(emissiveColor);",
            "                const hexString = '#' + gdjs.rgbToHex(rgbArray[0], rgbArray[1], rgbArray[2]);",
            "                node.material.emissive = new THREE.Color(hexString);",
            "                node.material.emissiveIntensity = parseFloat(emissiveIntensity);",
            "                node.material.emissiveMap = texture;",
            "                node.material.needsUpdate = true;                ",
            "            } else {",
            "                console.warn('Texture map property does not exist for this material type: ' + node.material.type + ', object name: ' + objects[0].getName());",
            "            }",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the IMesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "source",
          "longDescription": "source",
          "name": "source",
          "type": "imageResource"
        },
        {
          "description": "Flip the texture Y",
          "name": "flipY",
          "type": "trueorfalse"
        },
        {
          "description": "xRepeat",
          "name": "xRepeat",
          "type": "expression"
        },
        {
          "description": "yRepeat",
          "name": "yRepeat",
          "type": "expression"
        },
        {
          "description": "xOffset",
          "name": "xOffset",
          "type": "expression"
        },
        {
          "description": "yOffset",
          "name": "yOffset",
          "type": "expression"
        },
        {
          "description": "Rotation",
          "name": "rotation",
          "type": "expression"
        },
        {
          "description": "centerX",
          "name": "centerX",
          "type": "expression"
        },
        {
          "description": "centerY",
          "name": "centerY",
          "type": "expression"
        },
        {
          "description": "Color",
          "name": "emissiveColor",
          "type": "color"
        },
        {
          "description": "Intensity",
          "name": "emissiveIntensity",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "EmissiveMap animation",
      "fullName": "EmissiveMap animation",
      "functionType": "Action",
      "group": "Maps",
      "name": "EmissiveMapAnimation",
      "sentence": "EmissiveMap animation for: _PARAM1_  Min intensity: _PARAM2_  Max intensity: _PARAM3_ Speed: _PARAM4_  ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function oscillateEmissiveIntensity(runtimeScene, meshName, minIntensity, maxIntensity, speed) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const meshObjects = [];",
            "",
            "    threeScene.traverse((object) => {",
            "        if (object.name === meshName && (object.isMesh || object.isInstancedMesh)) {",
            "            meshObjects.push(object);",
            "        }",
            "    });",
            "",
            "    if (meshObjects.length === 0) {",
            "        return;",
            "    }",
            "",
            "    const currentTime = runtimeScene.getTimeManager().getTimeFromStart() / 1000;",
            "",
            "    const oscillation = Math.sin(currentTime * speed);",
            "",
            "    const normalizedOscillation = (oscillation + 1) / 2;",
            "",
            "    const intensityRange = maxIntensity - minIntensity;",
            "    const emissiveIntensity = minIntensity + (normalizedOscillation * intensityRange);",
            "",
            "    meshObjects.forEach((meshObject) => {",
            "        meshObject.traverse((node) => {",
            "            if (node.isMesh && node.material.isMaterial) {",
            "                node.material.emissiveIntensity = emissiveIntensity;",
            "                node.material.needsUpdate = true;",
            "            }",
            "        });",
            "    });",
            "}",
            "",
            "if (objects.length > 0) {",
            "    let objectMesh = objects[0];",
            "    let minIntensity = eventsFunctionContext.getArgument(\"minIntensity\");",
            "    let maxIntensity = eventsFunctionContext.getArgument(\"maxIntensity\");",
            "    let speed = eventsFunctionContext.getArgument(\"speed\");",
            "",
            "    oscillateEmissiveIntensity(",
            "  runtimeScene,",
            "  objectMesh.getName(),",
            "  eventsFunctionContext.getArgument(\"minIntensity\"),",
            "  eventsFunctionContext.getArgument(\"maxIntensity\"),",
            "  eventsFunctionContext.getArgument(\"speed\"),",
            ");",
            "} else {",
            "}",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Min intensity",
          "name": "minIntensity",
          "type": "expression"
        },
        {
          "description": "Max intensity",
          "name": "maxIntensity",
          "type": "expression"
        },
        {
          "description": "Speed",
          "name": "speed",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "EmissiveMap parameters",
      "fullName": "EmissiveMap parameters",
      "functionType": "Action",
      "group": "Maps",
      "name": "EmissiveMapParameters",
      "sentence": "EmissiveMap parameters for: _PARAM1_  Emission intensity: _PARAM2_  Color: _PARAM3_  xRepeat: _PARAM4_ yRepeat: _PARAM5_ xOffset: _PARAM6_ yOffset: _PARAM7_ Rotation: _PARAM8_  centerX: _PARAM9_ centerY: _PARAM10_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            if (!node.material.emissiveMap) {",
            "                node.material.emissiveMap = new THREE.Texture();",
            "              }",
            "            if (node.material.hasOwnProperty('emissiveMap')) {",
            "                let xRepeat = eventsFunctionContext.getArgument(\"xRepeat\");",
            "                let yRepeat = eventsFunctionContext.getArgument(\"yRepeat\");",
            "                let xOffset = eventsFunctionContext.getArgument(\"xOffset\");",
            "                let yOffset = eventsFunctionContext.getArgument(\"yOffset\");",
            "                let rotation = eventsFunctionContext.getArgument(\"rotation\");",
            "                let centerX = eventsFunctionContext.getArgument(\"centerX\");",
            "                let centerY = eventsFunctionContext.getArgument(\"centerY\");",
            "                let emissiveColor = eventsFunctionContext.getArgument(\"emissiveColor\");",
            "                let emissiveIntensity = eventsFunctionContext.getArgument(\"emissiveIntensity\");",
            "                var texture = textureLoader.load(textureMapName.substring(textureMapName.lastIndexOf('\\\\') + 1));",
            "                texture.repeat.set(xRepeat, yRepeat);",
            "                texture.offset.set(xOffset, yOffset);",
            "                texture.rotation = rotation;",
            "                texture.center.set(centerX, centerY);",
            "                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;",
            "                const rgbArray = gdjs.rgbOrHexToRGBColor(emissiveColor);",
            "                const hexString = '#' + gdjs.rgbToHex(rgbArray[0], rgbArray[1], rgbArray[2]);",
            "                child.material.emissive = new THREE.Color(hexString);",
            "                child.material.emissiveIntensity = parseFloat(emissiveIntensity);",
            "                node.material.needsUpdate = true;",
            "                ",
            "            } else {",
            "                console.warn('Texture map property does not exist for this material type: ' + node.material.type + ', object name: ' + objects[0].getName());",
            "            }",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Emissive intensity",
          "name": "emissiveIntensity",
          "type": "expression"
        },
        {
          "description": "Color",
          "name": "emissiveColor",
          "type": "color"
        },
        {
          "description": "xRepeat",
          "name": "xRepeat",
          "type": "expression"
        },
        {
          "description": "yRepeat",
          "name": "yRepeat",
          "type": "expression"
        },
        {
          "description": "xOffset",
          "name": "xOffset",
          "type": "expression"
        },
        {
          "description": "yOffset",
          "name": "yOffset",
          "type": "expression"
        },
        {
          "description": "Rotation",
          "name": "rotation",
          "type": "expression"
        },
        {
          "description": "centerX",
          "name": "centerX",
          "type": "expression"
        },
        {
          "description": "centerY",
          "name": "centerY",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "EnvMap",
      "fullName": "EnvMap",
      "functionType": "Action",
      "group": "Maps",
      "name": "EnvMap",
      "sentence": "EnvMap for: _PARAM1_ Intensity: _PARAM2_ px: _PARAM4_ nx: _PARAM6_ py: _PARAM8_ ny: _PARAM10_ pz: _PARAM12_ nz: _PARAM14_ flipY: _PARAM15_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "console.warn = function() {};",
            "console.error = function() {};",
            "",
            "let objectMesh;",
            "let objectPicked;",
            "if (objects.length > 0) {",
            "    objectMesh = objects[0];",
            "    objectPicked = objectMesh.getName();",
            "} else {",
            "}",
            "",
            "const ThreeRenderer = runtimeScene.getGame().getRenderer().getThreeRenderer();",
            "if (!ThreeRenderer) {",
            "    return;",
            "}",
            "",
            "",
            "const objectName = objectPicked;",
            "const Right = eventsFunctionContext.getArgument(\"pathPosX\");",
            "const Left = eventsFunctionContext.getArgument(\"pathNegX\");",
            "const Top = eventsFunctionContext.getArgument(\"pathPosY\");",
            "const Bottom = eventsFunctionContext.getArgument(\"pathNegY\");",
            "const Front = eventsFunctionContext.getArgument(\"pathPosZ\");",
            "const Back = eventsFunctionContext.getArgument(\"pathNegZ\");",
            "const FlipY = eventsFunctionContext.getArgument(\"flipY\");",
            "const Intensity = eventsFunctionContext.getArgument(\"intensity\");",
            "",
            "",
            "",
            "const FrontResource = runtimeScene.getGame().getImageManager().getPIXITexture(Front).baseTexture.resource;",
            "const BackResource = runtimeScene.getGame().getImageManager().getPIXITexture(Back).baseTexture.resource;",
            "const LeftResource = runtimeScene.getGame().getImageManager().getPIXITexture(Left).baseTexture.resource;",
            "const RightResource = runtimeScene.getGame().getImageManager().getPIXITexture(Right).baseTexture.resource;",
            "const TopResource = runtimeScene.getGame().getImageManager().getPIXITexture(Top).baseTexture.resource;",
            "const BottomResource = runtimeScene.getGame().getImageManager().getPIXITexture(Bottom).baseTexture.resource;",
            "",
            "",
            "",
            "const CubeTexture = new THREE.CubeTexture([LeftResource.source, RightResource.source, FrontResource.source, BackResource.source, TopResource.source, BottomResource.source]);",
            "CubeTexture.colorSpace = THREE.SRGBColorSpace;",
            "CubeTexture.needsUpdate = true;",
            "",
            "",
            "",
            "const pmremGenerator = new THREE.PMREMGenerator(ThreeRenderer);",
            "pmremGenerator.compileCubemapShader();",
            "",
            "",
            "",
            "const prefilteredCubemap = pmremGenerator.fromCubemap(CubeTexture).texture;",
            "pmremGenerator.dispose();",
            "",
            "",
            "",
            "const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "",
            "threeScene.traverse((child) => {",
            "  if (child.name === objectName && child.material) {",
            "    child.material.envMap = prefilteredCubemap;",
            "    child.material.envMapIntensity = Intensity;",
            "    child.material.needsUpdate = true;",
            "  }",
            "});",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Object's name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Intensity",
          "name": "intensity",
          "type": "expression"
        },
        {
          "description": "px",
          "name": "px",
          "supplementaryInformation": "[\"px\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "pathPosX",
          "name": "pathPosX",
          "type": "imageResource"
        },
        {
          "description": "nx",
          "name": "nx",
          "supplementaryInformation": "[\"nx\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "pathNegX",
          "name": "pathNegX",
          "type": "imageResource"
        },
        {
          "description": "py",
          "name": "py",
          "supplementaryInformation": "[\"py\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "pathPosY",
          "name": "pathPosY",
          "type": "imageResource"
        },
        {
          "description": "ny",
          "name": "ny",
          "supplementaryInformation": "[\"ny\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "pathNegY",
          "name": "pathNegY",
          "type": "imageResource"
        },
        {
          "description": "pz",
          "name": "pz",
          "supplementaryInformation": "[\"pz\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "pathPosZ",
          "name": "pathPosZ",
          "type": "imageResource"
        },
        {
          "description": "nz",
          "name": "nz",
          "supplementaryInformation": "[\"nz\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "pathNegZ",
          "name": "pathNegZ",
          "type": "imageResource"
        },
        {
          "description": "flipY",
          "name": "flipY",
          "type": "trueorfalse"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "ior",
      "fullName": "ior",
      "functionType": "Action",
      "group": "Maps",
      "name": "ior",
      "sentence": "ior of: _PARAM1_ Value: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            node.material.ior = eventsFunctionContext.getArgument(\"ior\");",
            "            node.material.needsUpdate = true;",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "ior (1-2.333)",
          "longDescription": "Mesh Physical material is required for ior ",
          "name": "ior",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Iridescence",
      "fullName": "Iridescence",
      "functionType": "Action",
      "group": "Maps",
      "name": "Iridescence",
      "sentence": "Iridescence of: _PARAM1_ Value: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            node.material.iridescence = eventsFunctionContext.getArgument(\"iridescence\");",
            "            node.material.needsUpdate = true;",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "iridescence (1-2.333)",
          "longDescription": "Mesh Physical material is required for iridescence",
          "name": "iridescence",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Normal Map",
      "fullName": "Normal Map",
      "functionType": "Action",
      "group": "Maps",
      "name": "NormalMap",
      "sentence": "Normal Map of: _PARAM1_  Source: _PARAM2_  FlipY: _PARAM3_ RepeatX: _PARAM4_  RepeatY: _PARAM5_  OffsetX: _PARAM6_  OffsetY: _PARAM7_  Rotation: _PARAM8_ CenterX: _PARAM9_ CenterY: _PARAM10_ ScaleX: _PARAM11_ ScaleY: _PARAM12_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            if (node.material.hasOwnProperty('normalMap')) {",
            "                if (node.material.normalMap instanceof THREE.Texture) {",
            "                    node.material.normalMap.dispose();",
            "                }",
            "                var textureLoader = new THREE.TextureLoader();",
            "                let textureMapName = eventsFunctionContext.getArgument(\"source\");",
            "                let flip = eventsFunctionContext.getArgument(\"flip\");",
            "                let xRepeat = eventsFunctionContext.getArgument(\"xRepeat\");",
            "                let yRepeat = eventsFunctionContext.getArgument(\"yRepeat\");",
            "                let xOffset = eventsFunctionContext.getArgument(\"xOffset\");",
            "                let yOffset = eventsFunctionContext.getArgument(\"yOffset\");",
            "                let rotation = eventsFunctionContext.getArgument(\"rotation\");",
            "                let centerX = eventsFunctionContext.getArgument(\"centerX\");",
            "                let centerY = eventsFunctionContext.getArgument(\"centerY\");",
            "                let normalScaleX = eventsFunctionContext.getArgument(\"normalScaleX\");",
            "                let normalScaleY = eventsFunctionContext.getArgument(\"normalScaleY\");",
            "                var texture = textureLoader.load(textureMapName.substring(textureMapName.lastIndexOf('\\\\') + 1));",
            "                if (flip) {",
            "                    texture.flipY = true;",
            "                } ",
            "                texture.repeat.set(xRepeat, yRepeat);",
            "                texture.offset.set(xOffset, yOffset);",
            "                texture.rotation = rotation;",
            "                texture.center.set(centerX, centerY);",
            "                node.material.normalScale.set(normalScaleX, normalScaleY);",
            "",
            "                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;",
            "                node.material.normalMap = texture;",
            "                node.material.needsUpdate = true;",
            "                ",
            "            } else {",
            "                console.warn('Texture map property does not exist for this material type: ' + node.material.type + ', object name: ' + objects[0].getName());",
            "            }",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "source",
          "longDescription": "source",
          "name": "source",
          "type": "imageResource"
        },
        {
          "description": "Flip the texture Y",
          "name": "flip",
          "type": "trueorfalse"
        },
        {
          "description": "xRepeat",
          "name": "xRepeat",
          "type": "expression"
        },
        {
          "description": "yRepeat",
          "name": "yRepeat",
          "type": "expression"
        },
        {
          "description": "xOffset",
          "name": "xOffset",
          "type": "expression"
        },
        {
          "description": "yOffset",
          "name": "yOffset",
          "type": "expression"
        },
        {
          "description": "Rotation",
          "name": "rotation",
          "type": "expression"
        },
        {
          "description": "Rotation centerX",
          "name": "centerX",
          "type": "expression"
        },
        {
          "description": "Rotation centerY",
          "name": "centerY",
          "type": "expression"
        },
        {
          "description": "normalScaleX",
          "name": "normalScaleX",
          "type": "expression"
        },
        {
          "description": "normalScaleY",
          "name": "normalScaleY",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Metallness Map",
      "fullName": "Metallness Map",
      "functionType": "Action",
      "group": "Maps",
      "name": "MetallnessMap",
      "sentence": "Metallness Map of: _PARAM1_  Source: _PARAM2_  FlipY: _PARAM3_ RepeatX: _PARAM4_  RepeatY: _PARAM5_  OffsetX: _PARAM6_  OffsetY: _PARAM7_  Rotation: _PARAM8_ CenterX: _PARAM9_ CenterY: _PARAM10_ Value: _PARAM11_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            if (node.material.hasOwnProperty('metalnessMap')) {",
            "                if (node.material.metalnessMap instanceof THREE.Texture) {",
            "                    node.material.metalnessMap.dispose();",
            "                }",
            "                var textureLoader = new THREE.TextureLoader();",
            "                let textureMapName = eventsFunctionContext.getArgument(\"source\");",
            "                let flip = eventsFunctionContext.getArgument(\"flip\");",
            "                let xRepeat = eventsFunctionContext.getArgument(\"xRepeat\");",
            "                let yRepeat = eventsFunctionContext.getArgument(\"yRepeat\");",
            "                let xOffset = eventsFunctionContext.getArgument(\"xOffset\");",
            "                let yOffset = eventsFunctionContext.getArgument(\"yOffset\");",
            "                let rotation = eventsFunctionContext.getArgument(\"rotation\");",
            "                let centerX = eventsFunctionContext.getArgument(\"centerX\");",
            "                let centerY = eventsFunctionContext.getArgument(\"centerY\");",
            "                let metallicValue = eventsFunctionContext.getArgument(\"value\");",
            "                var texture = textureLoader.load(textureMapName.substring(textureMapName.lastIndexOf('\\\\') + 1));",
            "                if (flip) {",
            "                    texture.flipY = true;",
            "                } ",
            "                texture.repeat.set(xRepeat, yRepeat);",
            "                texture.offset.set(xOffset, yOffset);",
            "                texture.rotation = rotation;",
            "                texture.center.set(centerX, centerY);",
            "                node.material.metalness = metallicValue;",
            "",
            "                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;",
            "                node.material.metalnessMap = texture;",
            "                node.material.needsUpdate = true;",
            "                ",
            "            } else {",
            "                console.warn('Texture map property does not exist for this material type: ' + node.material.type + ', object name: ' + objects[0].getName());",
            "            }",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of the InstancedMesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "source",
          "longDescription": "source",
          "name": "source",
          "type": "imageResource"
        },
        {
          "description": "Flip the texture Y",
          "name": "flip",
          "type": "trueorfalse"
        },
        {
          "description": "xRepeat",
          "name": "xRepeat",
          "type": "expression"
        },
        {
          "description": "yRepeat",
          "name": "yRepeat",
          "type": "expression"
        },
        {
          "description": "xOffset",
          "name": "xOffset",
          "type": "expression"
        },
        {
          "description": "yOffset",
          "name": "yOffset",
          "type": "expression"
        },
        {
          "description": "Rotation",
          "name": "rotation",
          "type": "expression"
        },
        {
          "description": "Rotation centerX",
          "name": "centerX",
          "type": "expression"
        },
        {
          "description": "Rotation centerY",
          "name": "centerY",
          "type": "expression"
        },
        {
          "description": "Value",
          "name": "value",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Metalness value",
      "fullName": "Metalness value",
      "functionType": "Action",
      "group": "Maps",
      "name": "MetalnessValue",
      "sentence": "Metalness of: _PARAM1_ value: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "                node.material.metalness = eventsFunctionContext.getArgument(\"value\");",
            "                node.material.needsUpdate = true;",
            "                ",
            "            } else {",
            "                console.log('Metalness value cant be changed');",
            "            }",
            "        }",
            "    )};",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Value",
          "name": "value",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Reflectivity ",
      "fullName": "Reflectivity ",
      "functionType": "Action",
      "group": "Maps",
      "name": "Reflectivity",
      "sentence": "Reflectivity of: _PARAM1_ Reflectivity value: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            node.material.reflectivity = eventsFunctionContext.getArgument(\"reflectivity\");",
            "            node.material.needsUpdate = true;",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Reflectivity (0-1)",
          "longDescription": "Mesh Physical material is required for reflectivity",
          "name": "reflectivity",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Roughness Map",
      "fullName": "Roughness Map",
      "functionType": "Action",
      "group": "Maps",
      "name": "RoughnessMap",
      "sentence": "Roughness Map of: _PARAM1_  Source: _PARAM2_  FlipY: _PARAM3_ RepeatX: _PARAM4_  RepeatY: _PARAM5_  OffsetX: _PARAM6_  OffsetY: _PARAM7_  Rotation: _PARAM8_ CenterX: _PARAM9_ CenterY: _PARAM10_ Value: _PARAM11_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            if (node.material.hasOwnProperty('roughnessMap')) {",
            "                if (node.material.roughnessMap instanceof THREE.Texture) {",
            "                    node.material.roughnessMap.dispose();",
            "                }",
            "                var textureLoader = new THREE.TextureLoader();",
            "                let textureMapName = eventsFunctionContext.getArgument(\"source\");",
            "                let flip = eventsFunctionContext.getArgument(\"flip\");",
            "                let xRepeat = eventsFunctionContext.getArgument(\"xRepeat\");",
            "                let yRepeat = eventsFunctionContext.getArgument(\"yRepeat\");",
            "                let xOffset = eventsFunctionContext.getArgument(\"xOffset\");",
            "                let yOffset = eventsFunctionContext.getArgument(\"yOffset\");",
            "                let rotation = eventsFunctionContext.getArgument(\"rotation\");",
            "                let centerX = eventsFunctionContext.getArgument(\"centerX\");",
            "                let centerY = eventsFunctionContext.getArgument(\"centerY\");",
            "                let roughnessValue = eventsFunctionContext.getArgument(\"value\");",
            "                var texture = textureLoader.load(textureMapName.substring(textureMapName.lastIndexOf('\\\\') + 1));",
            "                if (flip) {",
            "                    texture.flipY = true;",
            "                } ",
            "                texture.repeat.set(xRepeat, yRepeat);",
            "                texture.offset.set(xOffset, yOffset);",
            "                texture.rotation = rotation;",
            "                texture.center.set(centerX, centerY);",
            "                node.material.roughness = roughnessValue;",
            "",
            "                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;",
            "                node.material.roughnessMap = texture;",
            "                node.material.needsUpdate = true;",
            "                ",
            "            } else {",
            "                console.warn('Texture map property does not exist for this material type: ' + node.material.type + ', object name: ' + objects[0].getName());",
            "            }",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "source",
          "longDescription": "source",
          "name": "source",
          "type": "imageResource"
        },
        {
          "description": "Flip the texture Y",
          "name": "flip",
          "type": "trueorfalse"
        },
        {
          "description": "xRepeat",
          "name": "xRepeat",
          "type": "expression"
        },
        {
          "description": "yRepeat",
          "name": "yRepeat",
          "type": "expression"
        },
        {
          "description": "xOffset",
          "name": "xOffset",
          "type": "expression"
        },
        {
          "description": "yOffset",
          "name": "yOffset",
          "type": "expression"
        },
        {
          "description": "Rotation",
          "name": "rotation",
          "type": "expression"
        },
        {
          "description": "Rotation centerX",
          "name": "centerX",
          "type": "expression"
        },
        {
          "description": "Rotation centerY",
          "name": "centerY",
          "type": "expression"
        },
        {
          "description": "Value",
          "name": "value",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Roughness value",
      "fullName": "Roughness value",
      "functionType": "Action",
      "group": "Maps",
      "name": "RoughnessValue",
      "sentence": "Roughness of: _PARAM1_ value: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "                node.material.roughness = eventsFunctionContext.getArgument(\"value\");",
            "                node.material.needsUpdate = true;",
            "                ",
            "            } else {",
            "                console.log('Roughness value cant be changed');",
            "            }",
            "        }",
            "    )};",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Value",
          "name": "value",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Specular color",
      "fullName": "Specular color",
      "functionType": "Action",
      "group": "Maps",
      "name": "SpecularColor",
      "sentence": "Specular color of: _PARAM1_ Value: _PARAM2_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "  objects[0].get3DRendererObject().traverse((node) => {",
            "    if (node.isMesh && node.material.isMaterial) {",
            "      const rgbcolor = gdjs.rgbOrHexToRGBColor(eventsFunctionContext.getArgument(\"specularColor\"));",
            "      const hexColor = parseInt(\"0x\" + gdjs.rgbToHex(rgbcolor[0], rgbcolor[1], rgbcolor[2]), 16);",
            "",
            "      node.material.specularColor = new THREE.Color(hexColor);",
            "      node.material.needsUpdate = true;",
            "    }",
            "  });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "specularColor",
          "name": "specularColor",
          "type": "color"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Specular intensity",
      "fullName": "Specular intensity",
      "functionType": "Action",
      "group": "Maps",
      "name": "SpecularIntensity",
      "sentence": "Specular intensity of: _PARAM1_ Value: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            node.material.specularIntensity = eventsFunctionContext.getArgument(\"specularIntensity\");",
            "            node.material.needsUpdate = true;",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Thickness",
          "longDescription": "Mesh Physical material is required for specular intensity",
          "name": "specularIntensity",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Specular intensity map",
      "fullName": "Specular intensity map",
      "functionType": "Action",
      "group": "Maps",
      "name": "SpecularIntensityMap",
      "sentence": "Specular intensity map of: _PARAM1_  Source: _PARAM2_  FlipY: _PARAM3_ RepeatX: _PARAM4_  RepeatY: _PARAM5_  OffsetX: _PARAM6_  OffsetY: _PARAM7_  Rotation: _PARAM8_ CenterX: _PARAM9_ CenterY: _PARAM10_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "                if (node.material.map instanceof THREE.Texture) {",
            "                    node.material.map.dispose();",
            "                }",
            "                var textureLoader = new THREE.TextureLoader();",
            "                let textureMapName = eventsFunctionContext.getArgument(\"source\");",
            "                let flip = eventsFunctionContext.getArgument(\"flip\");",
            "                let xRepeat = eventsFunctionContext.getArgument(\"xRepeat\");",
            "                let yRepeat = eventsFunctionContext.getArgument(\"yRepeat\");",
            "                let xOffset = eventsFunctionContext.getArgument(\"xOffset\");",
            "                let yOffset = eventsFunctionContext.getArgument(\"yOffset\");",
            "                let rotation = eventsFunctionContext.getArgument(\"rotation\");",
            "                let centerX = eventsFunctionContext.getArgument(\"centerX\");",
            "                let centerY = eventsFunctionContext.getArgument(\"centerY\");",
            "                var texture = textureLoader.load(textureMapName.substring(textureMapName.lastIndexOf('\\\\') + 1));",
            "                ",
            "                if (flip) {",
            "                    texture.flipY = true;",
            "                } ",
            "                ",
            "                texture.repeat.set(xRepeat, yRepeat);",
            "                texture.offset.set(xOffset, yOffset);",
            "                texture.rotation = rotation;",
            "                texture.center.set(centerX, centerY);",
            "",
            "                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;",
            "                node.material.specularIntensityMap = texture;",
            "                node.material.needsUpdate = true;",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "source",
          "longDescription": "source",
          "name": "source",
          "type": "imageResource"
        },
        {
          "description": "Flip the texture Y",
          "name": "flip",
          "type": "trueorfalse"
        },
        {
          "description": "xRepeat",
          "name": "xRepeat",
          "type": "expression"
        },
        {
          "description": "yRepeat",
          "name": "yRepeat",
          "type": "expression"
        },
        {
          "description": "xOffset",
          "name": "xOffset",
          "type": "expression"
        },
        {
          "description": "yOffset",
          "name": "yOffset",
          "type": "expression"
        },
        {
          "description": "Rotation",
          "name": "rotation",
          "type": "expression"
        },
        {
          "description": "Rotation centerX",
          "name": "centerX",
          "type": "expression"
        },
        {
          "description": "Rotation centerY",
          "name": "centerY",
          "type": "expression"
        }
      ],
      "objectGroups": [
        {
          "name": "Group",
          "objects": [
            {
              "name": "id"
            }
          ]
        }
      ]
    },
    {
      "description": "Texture Map (color/diffuse/albedo map)",
      "fullName": "Texture Map",
      "functionType": "Action",
      "group": "Maps",
      "name": "TextureMap",
      "sentence": "Texture Map of: _PARAM1_  Source: _PARAM2_  FlipY: _PARAM3_ RepeatX: _PARAM4_  RepeatY: _PARAM5_  OffsetX: _PARAM6_  OffsetY: _PARAM7_  Rotation: _PARAM8_ CenterX: _PARAM9_ CenterY: _PARAM10_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            if (node.material.hasOwnProperty('map')) {",
            "                if (node.material.map instanceof THREE.Texture) {",
            "                    node.material.map.dispose();",
            "                }",
            "                var textureLoader = new THREE.TextureLoader();",
            "                let textureMapName = eventsFunctionContext.getArgument(\"source\");",
            "                let flip = eventsFunctionContext.getArgument(\"flip\");",
            "                let xRepeat = eventsFunctionContext.getArgument(\"xRepeat\");",
            "                let yRepeat = eventsFunctionContext.getArgument(\"yRepeat\");",
            "                let xOffset = eventsFunctionContext.getArgument(\"xOffset\");",
            "                let yOffset = eventsFunctionContext.getArgument(\"yOffset\");",
            "                let rotation = eventsFunctionContext.getArgument(\"rotation\");",
            "                let centerX = eventsFunctionContext.getArgument(\"centerX\");",
            "                let centerY = eventsFunctionContext.getArgument(\"centerY\");",
            "                var texture = textureLoader.load(textureMapName.substring(textureMapName.lastIndexOf('\\\\') + 1));",
            "                ",
            "                if (flip) {",
            "                    texture.flipY = true;",
            "                } ",
            "                ",
            "                texture.repeat.set(xRepeat, yRepeat);",
            "                texture.offset.set(xOffset, yOffset);",
            "                texture.rotation = rotation;",
            "                texture.center.set(centerX, centerY);",
            "",
            "                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;",
            "                node.material.map = texture;",
            "                node.material.needsUpdate = true;",
            "                ",
            "            } else {",
            "                console.warn('Texture map property does not exist for this material type: ' + node.material.type + ', object name: ' + objects[0].getName());",
            "            }",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "source",
          "longDescription": "source",
          "name": "source",
          "type": "imageResource"
        },
        {
          "description": "Flip the texture Y",
          "name": "flip",
          "type": "trueorfalse"
        },
        {
          "description": "xRepeat",
          "name": "xRepeat",
          "type": "expression"
        },
        {
          "description": "yRepeat",
          "name": "yRepeat",
          "type": "expression"
        },
        {
          "description": "xOffset",
          "name": "xOffset",
          "type": "expression"
        },
        {
          "description": "yOffset",
          "name": "yOffset",
          "type": "expression"
        },
        {
          "description": "Rotation",
          "name": "rotation",
          "type": "expression"
        },
        {
          "description": "Rotation centerX",
          "name": "centerX",
          "type": "expression"
        },
        {
          "description": "Rotation centerY",
          "name": "centerY",
          "type": "expression"
        }
      ],
      "objectGroups": [
        {
          "name": "Group",
          "objects": [
            {
              "name": "id"
            }
          ]
        }
      ]
    },
    {
      "description": "Thickness ",
      "fullName": "Thickness ",
      "functionType": "Action",
      "group": "Maps",
      "name": "Thickness",
      "sentence": "Thickness of: _PARAM1_ Value: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            node.material.thickness = eventsFunctionContext.getArgument(\"thickness\");",
            "            node.material.needsUpdate = true;",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Thickness",
          "longDescription": "Mesh Physical material is required for thickness",
          "name": "thickness",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Thickness Map",
      "fullName": "Thickness Map",
      "functionType": "Action",
      "group": "Maps",
      "name": "ThicknessMap",
      "sentence": "Thickness Map of: _PARAM1_  Source: _PARAM2_  FlipY: _PARAM3_ RepeatX: _PARAM4_  RepeatY: _PARAM5_  OffsetX: _PARAM6_  OffsetY: _PARAM7_  Rotation: _PARAM8_ CenterX: _PARAM9_ CenterY: _PARAM10_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "                if (node.material.map instanceof THREE.Texture) {",
            "                    node.material.map.dispose();",
            "                }",
            "                var textureLoader = new THREE.TextureLoader();",
            "                let textureMapName = eventsFunctionContext.getArgument(\"source\");",
            "                let flip = eventsFunctionContext.getArgument(\"flip\");",
            "                let xRepeat = eventsFunctionContext.getArgument(\"xRepeat\");",
            "                let yRepeat = eventsFunctionContext.getArgument(\"yRepeat\");",
            "                let xOffset = eventsFunctionContext.getArgument(\"xOffset\");",
            "                let yOffset = eventsFunctionContext.getArgument(\"yOffset\");",
            "                let rotation = eventsFunctionContext.getArgument(\"rotation\");",
            "                let centerX = eventsFunctionContext.getArgument(\"centerX\");",
            "                let centerY = eventsFunctionContext.getArgument(\"centerY\");",
            "                var texture = textureLoader.load(textureMapName.substring(textureMapName.lastIndexOf('\\\\') + 1));",
            "                ",
            "                if (flip) {",
            "                    texture.flipY = true;",
            "                } ",
            "                ",
            "                texture.repeat.set(xRepeat, yRepeat);",
            "                texture.offset.set(xOffset, yOffset);",
            "                texture.rotation = rotation;",
            "                texture.center.set(centerX, centerY);",
            "",
            "                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;",
            "                node.material.thicknessMap = texture;",
            "                node.material.needsUpdate = true;",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "source",
          "longDescription": "source",
          "name": "source",
          "type": "imageResource"
        },
        {
          "description": "Flip the texture Y",
          "name": "flip",
          "type": "trueorfalse"
        },
        {
          "description": "xRepeat",
          "name": "xRepeat",
          "type": "expression"
        },
        {
          "description": "yRepeat",
          "name": "yRepeat",
          "type": "expression"
        },
        {
          "description": "xOffset",
          "name": "xOffset",
          "type": "expression"
        },
        {
          "description": "yOffset",
          "name": "yOffset",
          "type": "expression"
        },
        {
          "description": "Rotation",
          "name": "rotation",
          "type": "expression"
        },
        {
          "description": "Rotation centerX",
          "name": "centerX",
          "type": "expression"
        },
        {
          "description": "Rotation centerY",
          "name": "centerY",
          "type": "expression"
        }
      ],
      "objectGroups": [
        {
          "name": "Group",
          "objects": [
            {
              "name": "id"
            }
          ]
        }
      ]
    },
    {
      "description": "ToneMap type",
      "fullName": "ToneMap type",
      "functionType": "Action",
      "group": "Maps",
      "name": "ToneMap",
      "sentence": "ToneMap type: _PARAM1_ Exposure: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "const ThreeRenderer = runtimeScene.getGame().getRenderer().getThreeRenderer();",
            "if (!ThreeRenderer) {",
            "    return;",
            "}",
            "",
            "const toneMappingType = eventsFunctionContext.getArgument(\"toneMappingType\");",
            "",
            "switch (toneMappingType) {",
            "    case \"NoToneMapping\":",
            "        ThreeRenderer.toneMapping = THREE.NoToneMapping;",
            "        break;",
            "    case \"LinearToneMapping\":",
            "        ThreeRenderer.toneMapping = THREE.LinearToneMapping;",
            "        break;",
            "    case \"ReinhardToneMapping\":",
            "        ThreeRenderer.toneMapping = THREE.ReinhardToneMapping;",
            "        break;",
            "    case \"CineonToneMapping\":",
            "        ThreeRenderer.toneMapping = THREE.CineonToneMapping;",
            "        break;",
            "    case \"ACESFilmicToneMapping\":",
            "        ThreeRenderer.toneMapping = THREE.ACESFilmicToneMapping;",
            "        break;",
            "    case \"AgXToneMapping\":",
            "        ThreeRenderer.toneMapping = THREE.AgXToneMapping;",
            "        break;",
            "    case \"NeutralToneMapping\":",
            "        ThreeRenderer.toneMapping = THREE.NeutralToneMapping;",
            "        break;",
            "    default:",
            "        console.error(\"Invalid tone mapping type entered or argument is missing.\");",
            "        return;",
            "}",
            "",
            "ThreeRenderer.toneMappingExposure = eventsFunctionContext.getArgument(\"exposure\"); ",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "ToneMappingType",
          "name": "toneMappingType",
          "supplementaryInformation": "[\"NoToneMapping\",\"LinearToneMapping\",\"ReinhardToneMapping\",\"CineonToneMapping\",\"ACESFilmicToneMapping\",\"AgXToneMapping\",\"NeutralToneMapping\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Exposure",
          "longDescription": "Default: 1",
          "name": "exposure",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Transmission",
      "fullName": "Transmission",
      "functionType": "Action",
      "group": "Maps",
      "name": "Transmission",
      "sentence": "Transmission of: _PARAM1_ Transmission value: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "            node.material.transmission = eventsFunctionContext.getArgument(\"transmission\");",
            "            node.material.needsUpdate = true;",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Transmission (0-1)",
          "longDescription": "Mesh Physical material is required for transmission",
          "name": "transmission",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Transmission Map",
      "fullName": "Transmission Map",
      "functionType": "Action",
      "group": "Maps",
      "name": "TransmissionMap",
      "sentence": "Transmission Map of: _PARAM1_  Source: _PARAM2_  FlipY: _PARAM3_ RepeatX: _PARAM4_  RepeatY: _PARAM5_  OffsetX: _PARAM6_  OffsetY: _PARAM7_  Rotation: _PARAM8_ CenterX: _PARAM9_ CenterY: _PARAM10_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (objects.length > 0) {",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh && node.material.isMaterial) {",
            "                if (node.material.map instanceof THREE.Texture) {",
            "                    node.material.map.dispose();",
            "                }",
            "                var textureLoader = new THREE.TextureLoader();",
            "                let textureMapName = eventsFunctionContext.getArgument(\"source\");",
            "                let flip = eventsFunctionContext.getArgument(\"flip\");",
            "                let xRepeat = eventsFunctionContext.getArgument(\"xRepeat\");",
            "                let yRepeat = eventsFunctionContext.getArgument(\"yRepeat\");",
            "                let xOffset = eventsFunctionContext.getArgument(\"xOffset\");",
            "                let yOffset = eventsFunctionContext.getArgument(\"yOffset\");",
            "                let rotation = eventsFunctionContext.getArgument(\"rotation\");",
            "                let centerX = eventsFunctionContext.getArgument(\"centerX\");",
            "                let centerY = eventsFunctionContext.getArgument(\"centerY\");",
            "                var texture = textureLoader.load(textureMapName.substring(textureMapName.lastIndexOf('\\\\') + 1));",
            "                ",
            "                if (flip) {",
            "                    texture.flipY = true;",
            "                } ",
            "                ",
            "                texture.repeat.set(xRepeat, yRepeat);",
            "                texture.offset.set(xOffset, yOffset);",
            "                texture.rotation = rotation;",
            "                texture.center.set(centerX, centerY);",
            "",
            "                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;",
            "                node.material.transmissionMap = texture;",
            "                node.material.needsUpdate = true;",
            "        }",
            "    });",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "source",
          "longDescription": "source",
          "name": "source",
          "type": "imageResource"
        },
        {
          "description": "Flip the texture Y",
          "name": "flip",
          "type": "trueorfalse"
        },
        {
          "description": "xRepeat",
          "name": "xRepeat",
          "type": "expression"
        },
        {
          "description": "yRepeat",
          "name": "yRepeat",
          "type": "expression"
        },
        {
          "description": "xOffset",
          "name": "xOffset",
          "type": "expression"
        },
        {
          "description": "yOffset",
          "name": "yOffset",
          "type": "expression"
        },
        {
          "description": "Rotation",
          "name": "rotation",
          "type": "expression"
        },
        {
          "description": "Rotation centerX",
          "name": "centerX",
          "type": "expression"
        },
        {
          "description": "Rotation centerY",
          "name": "centerY",
          "type": "expression"
        }
      ],
      "objectGroups": [
        {
          "name": "Group",
          "objects": [
            {
              "name": "id"
            }
          ]
        }
      ]
    },
    {
      "description": "Use sRGB",
      "fullName": "Use sRGB",
      "functionType": "Action",
      "group": "Maps",
      "name": "UseSRGB",
      "sentence": "Use sRGB: _PARAM1_ Use sRGB: _PARAM2_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "let meshName;",
            "let useSRGB = eventsFunctionContext.getArgument(\"useSRGB\");",
            "if (objects.length > 0) {",
            "  let objectMesh = objects[0];",
            "  meshName = objectMesh.getName();",
            "}",
            "",
            "var scene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "",
            "const gdObjects = runtimeScene.getObjects(meshName);",
            "",
            "if (!gdObjects || gdObjects.length === 0) {",
            "  return;",
            "}",
            "",
            "gdObjects.forEach(gdObject => {",
            "  var threeObject = gdObject.get3DRendererObject();",
            "",
            "  if (threeObject) {",
            "      threeObject.traverse(node => {",
            "          if (node.isMesh && node.material) {",
            "              node.name = meshName;",
            "              var mesh = scene.getObjectByName(meshName);",
            "",
            "              if (mesh && mesh.isMesh) {",
            "                  mesh.traverse((node) => {",
            "                      if (node.isMesh && node.material.isMaterial) {",
            "                          if (node.material.map) {",
            "                              if (useSRGB) {",
            "                                  node.material.map.colorSpace  = THREE.SRGBColorSpace;",
            "                              } else {",
            "                                  node.material.map.colorSpace  = THREE.LinearSRGBColorSpace",
            "                              }",
            "                              node.material.map.needsUpdate = true;",
            "                          }",
            "                          if (node.material.aoMap) {",
            "                              if (useSRGB) {",
            "                                  node.material.aoMap.encoding = THREE.sRGBEncoding;",
            "                              }",
            "                              node.material.aoMap.needsUpdate = true;",
            "                          }",
            "                          if (node.material.emissiveMap) {",
            "                              if (useSRGB) {",
            "                                  node.material.emissiveMap.encoding = THREE.sRGBEncoding;",
            "                              }",
            "                              node.material.emissiveMap.needsUpdate = true;",
            "                          }",
            "                      }",
            "                  });",
            "              }",
            "          }",
            "      });",
            "  }",
            "});",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Use sRGB ",
          "name": "useSRGB",
          "type": "trueorfalse"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Picked instance move",
      "fullName": "Picked instance move",
      "functionType": "Action",
      "getterName": "IsDistanceOfAnyInstance",
      "group": "Picked instances",
      "name": "PickedMove",
      "sentence": "Move instance of _PARAM1_ if it's variable _PARAM2_ equal to _PARAM3_ Axis: _PARAM4_ Operator: _PARAM5_ Value: _PARAM6_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function moveObject(runtimeScene, object, speed, operator, axis) {",
            "    let currentPositionX = object.getX();",
            "    let currentPositionY = object.getY();",
            "    let currentPositionZ = object.getZ();",
            "",
            "    let newPositionX = currentPositionX;",
            "    let newPositionY = currentPositionY;",
            "    let newPositionZ = currentPositionZ;",
            "",
            "    switch (axis) {",
            "        case 'x':",
            "            newPositionX = operator === '=' ? speed : currentPositionX + (operator === '+' ? speed : -speed);",
            "            break;",
            "        case 'y':",
            "            newPositionY = operator === '=' ? speed : currentPositionY + (operator === '+' ? speed : -speed);",
            "            break;",
            "        case 'z':",
            "            newPositionZ = operator === '=' ? speed : currentPositionZ + (operator === '+' ? speed : -speed);",
            "            break;",
            "        default:",
            "            return;",
            "    }",
            "",
            "    object.setX(newPositionX);",
            "    object.setY(newPositionY);",
            "    object.setZ(newPositionZ);",
            "}",
            "",
            "function moveInstancedMeshInstancesWithOperatorAndAxis(runtimeScene, meshName, speed, operator, axis, userDataKeys, userDataValues) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const instancedMesh = threeScene.getObjectByName(meshName);",
            "",
            "    if (!instancedMesh) {",
            "        return;",
            "    }",
            "",
            "    let movementVector = new THREE.Vector3();",
            "",
            "    switch (axis) {",
            "        case 'x':",
            "            movementVector.setX(speed);",
            "            break;",
            "        case 'y':",
            "            movementVector.setY(speed);",
            "            break;",
            "        case 'z':",
            "            movementVector.setZ(speed);",
            "            break;",
            "        default:",
            "            return;",
            "    }",
            "",
            "    if (operator === '-') {",
            "        movementVector.negate();",
            "    } else if (operator !== '+' && operator !== '=') {",
            "        return;",
            "    }",
            "",
            "    const getUserDataValue = (index) => {",
            "        return userDataValues[index % userDataValues.length];",
            "    };",
            "",
            "    if (instancedMesh.isInstancedMesh) {",
            "        for (let i = 0; i < instancedMesh.count; i++) {",
            "            if (!instancedMesh.userData[i]) {",
            "                instancedMesh.userData[i] = {};",
            "            }",
            "",
            "            const conditionResults = userDataKeys.every((key, index) => {",
            "                const conditionValue = instancedMesh.userData[i][key] || \"\";",
            "                return conditionValue === getUserDataValue(index);",
            "            });",
            "",
            "            if (conditionResults) {",
            "                const matrix = new THREE.Matrix4();",
            "                instancedMesh.getMatrixAt(i, matrix);",
            "",
            "                const position = new THREE.Vector3();",
            "                const quaternion = new THREE.Quaternion();",
            "                const scale = new THREE.Vector3();",
            "                matrix.decompose(position, quaternion, scale);",
            "",
            "                switch (operator) {",
            "                    case '=':",
            "                        if (axis === 'x') {",
            "                            position.setX(movementVector.x);",
            "                        } else if (axis === 'y') {",
            "                            position.setY(movementVector.y);",
            "                        } else if (axis === 'z') {",
            "                            position.setZ(movementVector.z);",
            "                        }",
            "                        break;",
            "                    case '+':",
            "                    case '-':",
            "                        position.add(movementVector);",
            "                        break;",
            "                }",
            "",
            "                matrix.compose(position, quaternion, scale);",
            "                instancedMesh.setMatrixAt(i, matrix);",
            "            }",
            "        }",
            "",
            "        instancedMesh.instanceMatrix.needsUpdate = true;",
            "        instancedMesh.updateMatrixWorld(true);",
            "    } else {",
            "        const objects = runtimeScene.getObjects(meshName);",
            "        objects.forEach(object => {",
            "            const threeObject = threeScene.getObjectByName(object.getName());",
            "            if (threeObject) {",
            "                if (!threeObject.userData) {",
            "                    threeObject.userData = {};",
            "                }",
            "",
            "                const conditionResults = userDataKeys.every((key, index) => {",
            "                    const conditionValue = threeObject.userData[key] || \"\";",
            "                    return conditionValue === getUserDataValue(index);",
            "                });",
            "",
            "                if (conditionResults) {",
            "                    moveObject(runtimeScene, object, speed, operator, axis);",
            "                }",
            "            }",
            "        });",
            "    }",
            "}",
            "",
            "if (objects.length > 0) {",
            "    const speed = parseFloat(eventsFunctionContext.getArgument(\"speed\"));",
            "    const operator = eventsFunctionContext.getArgument(\"operator\");",
            "    const axis = eventsFunctionContext.getArgument(\"axis\").toLowerCase();",
            "    const meshName = objects[0].getName();",
            "",
            "    const userDataKey = eventsFunctionContext.getArgument(\"userDataKey\").replace(/\\s+/g, '').split(',');",
            "    const userDataValue = eventsFunctionContext.getArgument(\"userDataValue\").replace(/\\s+/g, '').split(',');",
            "",
            "    moveInstancedMeshInstancesWithOperatorAndAxis(",
            "        runtimeScene,",
            "        meshName,",
            "        speed,",
            "        operator,",
            "        axis,",
            "        userDataKey,",
            "        userDataValue",
            "    );",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Mesh name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "If instance variable name equal to text",
          "name": "userDataKey",
          "type": "string"
        },
        {
          "description": "Text",
          "name": "userDataValue",
          "type": "string"
        },
        {
          "description": "Axis",
          "name": "axis",
          "supplementaryInformation": "[\"x\",\"y\",\"z\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Operator",
          "name": "operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Value",
          "name": "speed",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Picked instance scaling",
      "fullName": "Picked instance scaling",
      "functionType": "Action",
      "getterName": "IsDistanceOfAnyInstance",
      "group": "Picked instances",
      "name": "PickedScaling",
      "sentence": "Scale instance of _PARAM1_ if it's variable _PARAM2_ equal to _PARAM3_ Axis: _PARAM4_ Operator: _PARAM5_ Value: _PARAM6_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function scaleObject(runtimeScene, object, scaleFactor, operator, axis) {",
            "    const currentScaleX = object.getScaleX();",
            "    const currentScaleY = object.getScaleY();",
            "    const currentScaleZ = object.getScaleZ();",
            "",
            "    let newScaleX = currentScaleX;",
            "    let newScaleY = currentScaleY;",
            "    let newScaleZ = currentScaleZ;",
            "",
            "    if (operator === '=') {",
            "        if (axis === 'x') newScaleX = scaleFactor;",
            "        if (axis === 'y') newScaleY = scaleFactor;",
            "        if (axis === 'z') newScaleZ = scaleFactor;",
            "    } else if (operator === '+') {",
            "        if (axis === 'x') newScaleX = currentScaleX + scaleFactor;",
            "        if (axis === 'y') newScaleY = currentScaleY + scaleFactor;",
            "        if (axis === 'z') newScaleZ = currentScaleZ + scaleFactor;",
            "    } else if (operator === '-') {",
            "        if (axis === 'x') newScaleX = currentScaleX - scaleFactor;",
            "        if (axis === 'y') newScaleY = currentScaleY - scaleFactor;",
            "        if (axis === 'z') newScaleZ = currentScaleZ - scaleFactor;",
            "    }",
            "",
            "    object.setScaleX(Math.max(newScaleX, 0.01));",
            "    object.setScaleY(Math.max(newScaleY, 0.01));",
            "    object.setScaleZ(Math.max(newScaleZ, 0.01));",
            "}",
            "",
            "function scaleInstancedMeshInstancesWithOperatorAndAxis(runtimeScene, meshName, scaleFactor, operator, axis, customWordFromArgument, varText) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const instancedMesh = threeScene.getObjectByName(meshName);",
            "",
            "    if (!instancedMesh) {",
            "        return;",
            "    }",
            "",
            "    let scalingVector = new THREE.Vector3();",
            "",
            "    switch (axis) {",
            "        case 'x':",
            "            scalingVector.setX(scaleFactor);",
            "            break;",
            "        case 'y':",
            "            scalingVector.setY(scaleFactor);",
            "            break;",
            "        case 'z':",
            "            scalingVector.setZ(scaleFactor);",
            "            break;",
            "        default:",
            "            return;",
            "    }",
            "",
            "    if (operator === '-') {",
            "        scalingVector.negate();",
            "    } else if (operator !== '+' && operator !== '=') {",
            "        return;",
            "    }",
            "",
            "    const instanceShouldScale = {};",
            "    if (instancedMesh && instancedMesh.isInstancedMesh) {",
            "        for (let i = 0; i < instancedMesh.count; i++) {",
            "            if (!instancedMesh.userData[i]) {",
            "                instancedMesh.userData[i] = {};",
            "            }",
            "",
            "            const userDataValue = instancedMesh.userData[i][customWordFromArgument] || \"0\";",
            "            const normalizedVarText = varText === \"\" ? \"0\" : varText;",
            "",
            "            if (customWordFromArgument === \"\") {",
            "                instanceShouldScale[i] = true;",
            "            } else {",
            "                instanceShouldScale[i] = userDataValue === normalizedVarText;",
            "            }",
            "",
            "            if (instanceShouldScale[i]) {",
            "                const matrix = new THREE.Matrix4();",
            "                instancedMesh.getMatrixAt(i, matrix);",
            "",
            "                const position = new THREE.Vector3();",
            "                const quaternion = new THREE.Quaternion();",
            "                const scale = new THREE.Vector3();",
            "                matrix.decompose(position, quaternion, scale);",
            "",
            "                switch (operator) {",
            "                    case '=':",
            "                        scale.set(axis === 'x' ? Math.max(scalingVector.x, 0.01) : scale.x,",
            "                                  axis === 'y' ? Math.max(scalingVector.y, 0.01) : scale.y,",
            "                                  axis === 'z' ? Math.max(scalingVector.z, 0.01) : scale.z);",
            "                        break;",
            "                    case '+':",
            "                    case '-':",
            "                        scale.add(scalingVector);",
            "                        scale.set(Math.max(scale.x, 0.01), Math.max(scale.y, 0.01), Math.max(scale.z, 0.01));",
            "                        break;",
            "                    default:",
            "                        break;",
            "                }",
            "",
            "                matrix.compose(position, quaternion, scale);",
            "                instancedMesh.setMatrixAt(i, matrix);",
            "            }",
            "        }",
            "",
            "        instancedMesh.instanceMatrix.needsUpdate = true;",
            "        instancedMesh.updateMatrixWorld(true);",
            "    } else {",
            "        const objects = runtimeScene.getObjects(meshName);",
            "        objects.forEach(object => {",
            "            const threeObject = threeScene.getObjectByName(object.getName());",
            "            if (threeObject) {",
            "                if (!threeObject.userData) {",
            "                    threeObject.userData = {};",
            "                }",
            "                const userDataValue = threeObject.userData[customWordFromArgument] || \"0\"; ",
            "",
            "                if (customWordFromArgument === \"\") {",
            "                    scaleObject(runtimeScene, object, scaleFactor, operator, axis);",
            "                } else {",
            "                    const normalizedVarText = varText === \"\" ? \"0\" : varText; ",
            "                    const normalizedUserDataValue = userDataValue === \"\" ? \"0\" : userDataValue; ",
            "                    if (normalizedUserDataValue === normalizedVarText) {",
            "                        scaleObject(runtimeScene, object, scaleFactor, operator, axis);",
            "                    }",
            "                }",
            "            }",
            "        });",
            "    }",
            "}",
            "",
            "if (objects.length > 0) {",
            "    const scaleFactor = parseFloat(eventsFunctionContext.getArgument(\"value\"));",
            "    const operator = eventsFunctionContext.getArgument(\"operator\");",
            "    const axis = eventsFunctionContext.getArgument(\"axis\").toLowerCase();",
            "    const meshName = objects[0].getName();",
            "    const customWordFromArgument = eventsFunctionContext.getArgument(\"varName\");",
            "    const varText = eventsFunctionContext.getArgument(\"varText\");",
            "",
            "    scaleInstancedMeshInstancesWithOperatorAndAxis(runtimeScene, meshName, scaleFactor, operator, axis, customWordFromArgument, varText);",
            "}",
            ""
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Mesh name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "If instance variable name equal to text",
          "name": "varName",
          "type": "string"
        },
        {
          "description": "Text",
          "name": "varText",
          "type": "string"
        },
        {
          "description": "Axis",
          "name": "axis",
          "supplementaryInformation": "[\"x\",\"y\",\"z\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Operator",
          "name": "operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Value",
          "name": "value",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Picked instance rotation",
      "fullName": "Picked instance rotation",
      "functionType": "Action",
      "getterName": "IsDistanceOfAnyInstance",
      "group": "Picked instances",
      "name": "PickedRotate",
      "sentence": "Rotate instance of _PARAM1_ if it's variable _PARAM2_ equal to _PARAM3_ Axis: _PARAM4_ Operator: _PARAM5_ Value: _PARAM6_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function rotateObject(runtimeScene, object, rotationAmount, operator, axis) {",
            "    const currentRotation = object.getAngle();",
            "    let newRotation = 0;",
            "    ",
            "    if (operator === '=') {",
            "        newRotation = rotationAmount;",
            "    } else if (operator === '+') {",
            "        newRotation = currentRotation + rotationAmount;",
            "    } else if (operator === '-') {",
            "        newRotation = currentRotation - rotationAmount;",
            "    }",
            "    ",
            "    if (axis === 'x') {",
            "        object.setAngle(newRotation);",
            "    } else if (axis === 'y') {",
            "        object.setYRotation(newRotation);",
            "    } else if (axis === 'z') {",
            "        object.setZRotation(newRotation);",
            "    }",
            "}",
            "",
            "function rotateInstancedMeshInstancesWithOperator(runtimeScene, meshName, rotationAmount, customWordsFromArgument, operator, axis, varTexts) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const instancedMesh = threeScene.getObjectByName(meshName);",
            "",
            "    if (!instancedMesh) {",
            "        return;",
            "    }",
            "",
            "    const rotationChange = THREE.MathUtils.degToRad(rotationAmount);",
            "",
            "    const instanceShouldRotate = {};",
            "    if (instancedMesh && instancedMesh.isInstancedMesh) {",
            "        for (let i = 0; i < instancedMesh.count; i++) {",
            "            if (!instancedMesh.userData[i]) {",
            "                instancedMesh.userData[i] = {};",
            "            }",
            "",
            "            instanceShouldRotate[i] = customWordsFromArgument.every((customWord, index) => {",
            "                const userDataValue = instancedMesh.userData[i][customWord] || \"0\";",
            "                const normalizedVarText = varTexts[index % varTexts.length] === \"\" ? \"0\" : varTexts[index % varTexts.length];",
            "                const normalizedUserDataValue = userDataValue === \"\" ? \"0\" : userDataValue;",
            "                return normalizedUserDataValue === normalizedVarText;",
            "            });",
            "        }",
            "",
            "        for (let i = 0; i < instancedMesh.count; i++) {",
            "            if (instanceShouldRotate[i]) {",
            "                const matrix = new THREE.Matrix4();",
            "                instancedMesh.getMatrixAt(i, matrix);",
            "",
            "                const position = new THREE.Vector3();",
            "                const quaternion = new THREE.Quaternion();",
            "                const scale = new THREE.Vector3();",
            "                matrix.decompose(position, quaternion, scale);",
            "",
            "                if (operator === '=') {",
            "                    const euler = new THREE.Euler(0, 0, 0, 'ZYX');",
            "                    euler[axis] = rotationChange;",
            "                    quaternion.setFromEuler(euler);",
            "                } else if (operator === '+' || operator === '-') {",
            "                    const axisVector = new THREE.Vector3(axis === 'x' ? 1 : 0, axis === 'y' ? 1 : 0, axis === 'z' ? 1 : 0);",
            "                    const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(axisVector, (operator === '+') ? rotationChange : -rotationChange);",
            "                    quaternion.multiply(rotationQuaternion);",
            "                }",
            "",
            "                matrix.compose(position, quaternion, scale);",
            "                instancedMesh.setMatrixAt(i, matrix);",
            "            }",
            "        }",
            "",
            "        instancedMesh.instanceMatrix.needsUpdate = true;",
            "    } else {",
            "        const objects = runtimeScene.getObjects(meshName);",
            "        objects.forEach(object => {",
            "            const threeObject = threeScene.getObjectByName(object.getName());",
            "            if (threeObject) {",
            "                if (!threeObject.userData) {",
            "                    threeObject.userData = {};",
            "                }",
            "",
            "                const shouldRotate = customWordsFromArgument.every((customWord, index) => {",
            "                    const userDataValue = threeObject.userData[customWord] || \"0\";",
            "                    const normalizedVarText = varTexts[index % varTexts.length] === \"\" ? \"0\" : varTexts[index % varTexts.length];",
            "                    const normalizedUserDataValue = userDataValue === \"\" ? \"0\" : userDataValue;",
            "                    return normalizedUserDataValue === normalizedVarText;",
            "                });",
            "",
            "                if (shouldRotate) {",
            "                    rotateObject(runtimeScene, object, rotationAmount, operator, axis);",
            "                }",
            "            }",
            "        });",
            "    }",
            "}",
            "",
            "if (objects.length > 0) {",
            "    const rotationAmount = parseFloat(eventsFunctionContext.getArgument(\"rotation\"));",
            "    const operator = eventsFunctionContext.getArgument(\"operator\");",
            "    const axis = eventsFunctionContext.getArgument(\"axis\").toLowerCase();",
            "    const customWordsFromArgument = eventsFunctionContext.getArgument(\"varName\").replace(/\\s+/g, '').split(',');",
            "    const varTexts = eventsFunctionContext.getArgument(\"varText\").replace(/\\s+/g, '').split(',');",
            "    const meshName = objects[0].getName();",
            "",
            "    rotateInstancedMeshInstancesWithOperator(runtimeScene, meshName, rotationAmount, customWordsFromArgument, operator, axis, varTexts);",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Mesh name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "If instance variable name equal to text",
          "name": "varName",
          "type": "string"
        },
        {
          "description": "Text",
          "name": "varText",
          "type": "string"
        },
        {
          "description": "Axis",
          "name": "axis",
          "supplementaryInformation": "[\"x\",\"y\",\"z\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Operator",
          "name": "operator",
          "supplementaryInformation": "[\"=\",\"+\",\"-\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Value",
          "name": "rotation",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Picked instance variable change",
      "fullName": "Picked instance variable change",
      "functionType": "Action",
      "getterName": "IsDistanceOfAnyInstance",
      "group": "Picked instances",
      "name": "PickedVarChange",
      "sentence": "Instance variable of _PARAM1_ do for all _PARAM2_ if it's variable _PARAM3_ equal to _PARAM4_ a variable: _PARAM5_ is changed to: _PARAM6_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function checkInstancesConditionAndSetUserData(runtimeScene, meshName, conditionVarsString, conditionVarsText, actionVarsString, actionVarsText, forAll) {",
            "    const instancedMesh = runtimeScene.getLayer('').getRenderer().getThreeScene().getObjectByName(meshName);",
            "",
            "    if (instancedMesh && instancedMesh.isInstancedMesh) {",
            "        let instancesToUpdate = [];",
            "        const conditionVars = conditionVarsString.replace(/\\s+/g, '').split(',');",
            "        const conditionVarsTextArray = conditionVarsText.replace(/\\s+/g, '').split(',');",
            "        const actionVars = actionVarsString.replace(/\\s+/g, '').split(',');",
            "        const actionVarsTextArray = actionVarsText.replace(/\\s+/g, '').split(',');",
            "",
            "        for (let i = 0; i < instancedMesh.count; i++) {",
            "            if (!instancedMesh.userData[i]) {",
            "                instancedMesh.userData[i] = {};",
            "            }",
            "",
            "            let conditionMet = true;",
            "",
            "            if (conditionVars.length === 0 && conditionVarsTextArray.length === 0) {",
            "                conditionMet = true;",
            "            } else {",
            "                for (let j = 0; j < conditionVars.length; j++) {",
            "                    const conditionValue = instancedMesh.userData[i][conditionVars[j]] || \"0\";",
            "                    const expectedValue = conditionVarsTextArray[j % conditionVarsTextArray.length] === \"\" ? \"0\" : conditionVarsTextArray[j % conditionVarsTextArray.length];",
            "",
            "                    if (conditionValue !== expectedValue) {",
            "                        conditionMet = false;",
            "                        break;",
            "                    }",
            "                }",
            "            }",
            "",
            "            if (conditionMet) {",
            "                instancesToUpdate.push(i);",
            "            }",
            "        }",
            "",
            "        if (forAll) {",
            "            instancesToUpdate.forEach(index => {",
            "                actionVars.forEach((actionVar, j) => {",
            "                    instancedMesh.userData[index][actionVar] = actionVarsTextArray[j % actionVarsTextArray.length];",
            "                });",
            "            });",
            "        } else if (instancesToUpdate.length > 0) {",
            "            const index = Math.min(...instancesToUpdate);",
            "            actionVars.forEach((actionVar, j) => {",
            "                instancedMesh.userData[index][actionVar] = actionVarsTextArray[j % actionVarsTextArray.length];",
            "            });",
            "        }",
            "    }",
            "}",
            "",
            "if (objects.length > 0) {",
            "    const meshName = objects[0].getName();",
            "    const conditionVarsString = eventsFunctionContext.getArgument(\"conditionVars\");",
            "    const conditionVarsText = eventsFunctionContext.getArgument(\"conditionVarsText\");",
            "    const actionVarsString = eventsFunctionContext.getArgument(\"actionVars\");",
            "    const actionVarsText = eventsFunctionContext.getArgument(\"actionVarsText\");",
            "    const forAll = eventsFunctionContext.getArgument(\"forAll\");",
            "",
            "    checkInstancesConditionAndSetUserData(runtimeScene, meshName, conditionVarsString, conditionVarsText, actionVarsString, actionVarsText, forAll);",
            "",
            "    eventsFunctionContext.returnValue = true;",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Mesh name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Do for all instances of the mesh",
          "name": "forAll",
          "type": "trueorfalse"
        },
        {
          "description": "If instance variable name equal to text",
          "name": "conditionVars",
          "type": "string"
        },
        {
          "description": "Text",
          "name": "conditionVarsText",
          "type": "string"
        },
        {
          "description": "The variable name",
          "name": "actionVars",
          "type": "string"
        },
        {
          "description": "Is changed to",
          "name": "actionVarsText",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Number of instances of InstancedMesh",
      "fullName": "Number of instances of InstancedMesh",
      "functionType": "ExpressionAndCondition",
      "name": "NumberOfInstances",
      "sentence": "Number of instances of InstancedMesh: _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getTotalInstancedMeshInstanceCount(runtimeScene, meshNamesList) {",
            "",
            "  var totalCount = 0;",
            "",
            "",
            "  var meshNames = meshNamesList.split(\",\");",
            "",
            " ",
            "  meshNames.forEach(function(meshName) {",
            "",
            "    var instancedMesh = runtimeScene.getLayer('').getRenderer().getThreeScene().getObjectByName(meshName.trim());",
            "",
            "",
            "    if (instancedMesh) {",
            "",
            "      totalCount += instancedMesh.count;",
            "    }",
            "  });",
            "",
            "  return totalCount;",
            "}",
            "",
            "var totalInstanceCount = getTotalInstancedMeshInstanceCount(runtimeScene, eventsFunctionContext.getArgument(\"id\"));",
            "eventsFunctionContext.returnValue = totalInstanceCount;"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Number of instances of InstanceMesh",
          "name": "id",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Number of instances of all InstancedMeshes",
      "fullName": "Number of instances of all InstancedMeshes",
      "functionType": "ExpressionAndCondition",
      "name": "NumberOf_ALL_Instances",
      "sentence": "Number of All instances",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getAllInstancedMeshNames(runtimeScene) {",
            "    var threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    var allInstancedMeshNames = [];",
            "",
            "    threeScene.traverse(function (object) {",
            "        if (object.isInstancedMesh) {",
            "            allInstancedMeshNames.push(object.name);",
            "        }",
            "    });",
            "",
            "  ",
            "    return allInstancedMeshNames.join(', ');",
            "}",
            "",
            "",
            "var instancedMeshNames = getAllInstancedMeshNames(runtimeScene);",
            "runtimeScene.getVariables().get(\"AllInstancedMeshNamesList\").setString(instancedMeshNames);"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        },
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getTotalInstancedMeshInstanceCount(runtimeScene, meshNamesVar) {",
            " ",
            "    var totalCount = 0;",
            "",
            "   ",
            "    var meshNamesList = runtimeScene.getVariables().get(meshNamesVar).getAsString();",
            "",
            "  ",
            "    var meshNames = meshNamesList.split(\",\");",
            "",
            "   ",
            "    meshNames.forEach(function(meshName) {",
            "       ",
            "        var instancedMesh = runtimeScene.getLayer('').getRenderer().getThreeScene().getObjectByName(meshName.trim());",
            "",
            "       ",
            "        if (instancedMesh) {",
            "           ",
            "            totalCount += instancedMesh.count;",
            "        }",
            "    });",
            "",
            "    ",
            "    return totalCount;",
            "}",
            "",
            "",
            "var totalInstanceCount = getTotalInstancedMeshInstanceCount(runtimeScene, \"AllInstancedMeshNamesList\");",
            "eventsFunctionContext.returnValue = totalInstanceCount;"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Names of all instanced meshes on the scene",
      "fullName": "Names of all instanced meshes on the scene",
      "functionType": "StringExpression",
      "name": "AllInstancedMeshesNames",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getAllInstancedMeshNames(runtimeScene) {",
            "    var threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    var allInstancedMeshNames = [];",
            "",
            "    threeScene.traverse(function (object) {",
            "        if (object.isInstancedMesh) {",
            "            allInstancedMeshNames.push(object.name);",
            "        }",
            "    });",
            "",
            " ",
            "    return allInstancedMeshNames.join(', ');",
            "}",
            "",
            "var instancedMeshNames = getAllInstancedMeshNames(runtimeScene);",
            "eventsFunctionContext.returnValue = instancedMeshNames;"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Is distance of any instance",
      "fullName": "Is distance of any instance",
      "functionType": "Condition",
      "name": "IsAnyInstanceDistance",
      "sentence": "Is distance of any instance of: _PARAM1_ Target points X: _PARAM2_ Y: _PARAM3_ Z: _PARAM4_ Operator: _PARAM5_ Distance: _PARAM6_ ConditionVar: _PARAM7_ ConditionText: _PARAM8_ Change var named: _PARAM9_ ToText: _PARAM10_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getDistanceToPoint(x1, y1, z1, position2) {",
            "    const position1 = new THREE.Vector3(x1, y1, z1);",
            "    return position1.distanceTo(position2);",
            "}",
            "",
            "function checkObjectsDistanceAndSetVariable(runtimeScene, objectName, pointX, pointY, pointZ, thresholdDistance, operator, userDataKeys, userDataValues, conditionUserDataKeys, conditionUserDataValues) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const objects = runtimeScene.getObjects(objectName);",
            "    const threeObject = threeScene.getObjectByName(objectName);",
            "",
            "    const isInstancedMesh = (obj) => obj && obj.isInstancedMesh;",
            "",
            "    const getObjectPosition = (obj, isInstanced, index) => {",
            "        if (isInstanced) {",
            "            const matrix = new THREE.Matrix4();",
            "            obj.getMatrixAt(index, matrix);",
            "            const instancePosition = new THREE.Vector3();",
            "            instancePosition.setFromMatrixPosition(matrix);",
            "            return instancePosition;",
            "        } else {",
            "            return new THREE.Vector3(obj.getX(), obj.getY(), obj.getZ());",
            "        }",
            "    };",
            "",
            "    const checkCondition = (distance, operator, thresholdDistance) => {",
            "        switch (operator) {",
            "            case \"=\":",
            "                return distance === thresholdDistance;",
            "            case \">\":",
            "                return distance > thresholdDistance;",
            "            case \"<\":",
            "                return distance < thresholdDistance;",
            "            default:",
            "                return false;",
            "        }",
            "    };",
            "",
            "    const setUserData = (mesh, index, keys, values) => {",
            "        if (!mesh.userData) {",
            "            mesh.userData = {};",
            "        }",
            "        if (!mesh.userData[index]) {",
            "            mesh.userData[index] = {};",
            "        }",
            "        keys.forEach((key, i) => {",
            "            mesh.userData[index][key] = values[i % values.length];",
            "        });",
            "    };",
            "",
            "    const normalizeValue = (value) => {",
            "        return value === undefined || value === \"\" || value === \"0\" ? \"0\" : value;",
            "    };",
            "",
            "    const processInstancedMesh = (instancedMesh) => {",
            "        for (let i = 0; i < instancedMesh.count; i++) {",
            "            const instancePosition = getObjectPosition(instancedMesh, true, i);",
            "            const distance = getDistanceToPoint(pointX, pointY, pointZ, instancePosition);",
            "",
            "            const conditionResults = conditionUserDataKeys.every((key, index) => {",
            "                const conditionValue = instancedMesh.userData[i] ? instancedMesh.userData[i][key] : \"0\";",
            "                return normalizeValue(conditionValue) === normalizeValue(conditionUserDataValues[index % conditionUserDataValues.length]);",
            "            });",
            "",
            "            if (conditionResults && checkCondition(distance, operator, thresholdDistance)) {",
            "                setUserData(instancedMesh, i, userDataKeys, userDataValues);",
            "            }",
            "        }",
            "    };",
            "",
            "    const processGDevelopObject = (gdevelopObject) => {",
            "        const objectPosition = getObjectPosition(gdevelopObject, false);",
            "        const distance = getDistanceToPoint(pointX, pointY, pointZ, objectPosition);",
            "",
            "        const conditionResults = conditionUserDataKeys.every((key, index) => {",
            "            const conditionValue = gdevelopObject.getRendererObject().userData[key] || \"0\";",
            "            return normalizeValue(conditionValue) === normalizeValue(conditionUserDataValues[index % conditionUserDataValues.length]);",
            "        });",
            "",
            "        if (conditionResults && checkCondition(distance, operator, thresholdDistance)) {",
            "            userDataKeys.forEach((key, index) => {",
            "                gdevelopObject.getRendererObject().userData[key] = userDataValues[index % userDataValues.length];",
            "            });",
            "        }",
            "    };",
            "",
            "    if (isInstancedMesh(threeObject)) {",
            "        processInstancedMesh(threeObject);",
            "    } else {",
            "        objects.forEach(processGDevelopObject);",
            "    }",
            "}",
            "",
            "if (objects.length > 0) {",
            "    const pointX = parseFloat(eventsFunctionContext.getArgument(\"x1\"));",
            "    const pointY = parseFloat(eventsFunctionContext.getArgument(\"y1\"));",
            "    const pointZ = parseFloat(eventsFunctionContext.getArgument(\"z1\"));",
            "    const objectName = objects[0].getName();",
            "    const thresholdDistance = parseFloat(eventsFunctionContext.getArgument(\"Distance\"));",
            "    const operator = eventsFunctionContext.getArgument(\"operator\");",
            "",
            "    const userDataKey = eventsFunctionContext.getArgument(\"varName\").replace(/\\s+/g, '').split(',');",
            "    const userDataValue = eventsFunctionContext.getArgument(\"varText\").replace(/\\s+/g, '').split(',');",
            "    const conditionUserDataKey = eventsFunctionContext.getArgument(\"conditionVar\").replace(/\\s+/g, '').split(',');",
            "    const conditionUserDataValue = eventsFunctionContext.getArgument(\"conditionVarText\").replace(/\\s+/g, '').split(',');",
            "",
            "    checkObjectsDistanceAndSetVariable(runtimeScene, objectName, pointX, pointY, pointZ, thresholdDistance, operator, userDataKey, userDataValue, conditionUserDataKey, conditionUserDataValue);",
            "",
            "    eventsFunctionContext.returnValue = true;",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "PointX",
          "name": "x1",
          "type": "expression"
        },
        {
          "description": "PointY",
          "name": "y1",
          "type": "expression"
        },
        {
          "description": "PointZ",
          "name": "z1",
          "type": "expression"
        },
        {
          "description": "Operator",
          "name": "operator",
          "supplementaryInformation": "[\"=\",\">\",\"<\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Distance",
          "name": "Distance",
          "type": "expression"
        },
        {
          "description": "conditionVar",
          "longDescription": "If the condition variable equal to condition text",
          "name": "conditionVar",
          "type": "string"
        },
        {
          "description": "conditionText",
          "longDescription": "Condition text",
          "name": "conditionVarText",
          "type": "string"
        },
        {
          "description": "Instance variable name",
          "longDescription": "Change the instance variable if the condition variable exists",
          "name": "varName",
          "type": "string"
        },
        {
          "description": "Variable text",
          "name": "varText",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Is position of any instance",
      "fullName": "Is position of any instance",
      "functionType": "Condition",
      "name": "IsAnyInstancePosition",
      "sentence": "Is position of any instance of: _PARAM1_ Axis: _PARAM2_ Operator: _PARAM3_ Value: _PARAM4_ ConditionVar: _PARAM5_ ConditionText: _PARAM6_ VarName: _PARAM7_ VarText: _PARAM8_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function checkObjectsPositionAndSetUserData(runtimeScene, objectName, axis, value, operator, userDataPrefixes, userDataTexts, conditionUserDataKeys, conditionUserDataValues) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const object = runtimeScene.getObjects(objectName)[0];",
            "    const threeObject = threeScene.getObjectByName(objectName);",
            "",
            "    const isInstancedMesh = (obj) => obj.isInstancedMesh;",
            "",
            "    const getObjectPosition = (obj, isInstanced, index) => {",
            "        if (isInstanced) {",
            "            const matrix = new THREE.Matrix4();",
            "            obj.getMatrixAt(index, matrix);",
            "            const instancePosition = new THREE.Vector3();",
            "            instancePosition.setFromMatrixPosition(matrix);",
            "            instancePosition.y *= 1; ",
            "            return instancePosition;",
            "        } else {",
            "            return new THREE.Vector3(obj.getX(), obj.getY() * 1, obj.getZ()); ",
            "        }",
            "    };",
            "",
            "    const checkCondition = (value1, operator, value2) => {",
            "        switch (operator) {",
            "            case \"=\":",
            "                return value1 === value2;",
            "            case \">\":",
            "                return value1 > value2;",
            "            case \"<\":",
            "                return value1 < value2;",
            "            case \">=\":",
            "                return value1 >= value2;",
            "            case \"<=\":",
            "                return value1 <= value2;",
            "            default:",
            "                return false;",
            "        }",
            "    };",
            "",
            "    const setUserData = (mesh, index, keys, values) => {",
            "        if (!mesh.userData) {",
            "            mesh.userData = {};",
            "        }",
            "        if (!mesh.userData[index]) {",
            "            mesh.userData[index] = {};",
            "        }",
            "        keys.forEach((key, i) => {",
            "            mesh.userData[index][key] = values[i % values.length];",
            "        });",
            "    };",
            "",
            "    const normalizeValue = (value) => {",
            "        return value === undefined || value === \"\" || value === \"0\" ? \"0\" : value;",
            "    };",
            "",
            "    const processInstancedMesh = (instancedMesh) => {",
            "        for (let i = 0; i < instancedMesh.count; i++) {",
            "            if (!instancedMesh.userData[i]) {",
            "                instancedMesh.userData[i] = {};",
            "            }",
            "",
            "            const conditionResults = conditionUserDataKeys.every((key, index) => {",
            "                const conditionValue = instancedMesh.userData[i][key] || \"0\";",
            "                return normalizeValue(conditionValue) === normalizeValue(conditionUserDataValues[index % conditionUserDataValues.length]);",
            "            });",
            "",
            "            if (!conditionResults) {",
            "                continue; ",
            "            }",
            "",
            "            const instancePosition = getObjectPosition(instancedMesh, true, i);",
            "            const instanceValue = instancePosition[axis.toLowerCase()];",
            "",
            "            if (checkCondition(instanceValue, operator, value)) {",
            "                setUserData(instancedMesh, i, userDataPrefixes, userDataTexts);",
            "            }",
            "        }",
            "    };",
            "",
            "    const processGDevelopObject = (gdevelopObject) => {",
            "        if (!threeObject.userData) {",
            "            threeObject.userData = {};",
            "        }",
            "",
            "        const conditionResults = conditionUserDataKeys.every((key, index) => {",
            "            const conditionValue = threeObject.userData[key] || \"0\";",
            "            return normalizeValue(conditionValue) === normalizeValue(conditionUserDataValues[index % conditionUserDataValues.length]);",
            "        });",
            "",
            "        if (!conditionResults) {",
            "            return; ",
            "        }",
            "",
            "        const objectPosition = getObjectPosition(gdevelopObject, false);",
            "        const objectValue = objectPosition[axis.toLowerCase()];",
            "",
            "        if (checkCondition(objectValue, operator, value)) {",
            "            userDataPrefixes.forEach((key, i) => {",
            "                threeObject.userData[key] = userDataTexts[i % userDataTexts.length];",
            "            });",
            "        }",
            "    };",
            "",
            "    if (isInstancedMesh(threeObject)) {",
            "        processInstancedMesh(threeObject);",
            "    } else {",
            "        processGDevelopObject(object);",
            "    }",
            "}",
            "",
            "if (objects.length > 0) {",
            "    const objectName = objects[0].getName();",
            "    const axis = eventsFunctionContext.getArgument(\"axis\");",
            "    const value = parseFloat(eventsFunctionContext.getArgument(\"value\"));",
            "    const operator = eventsFunctionContext.getArgument(\"operator\");",
            "    const userDataPrefixes = eventsFunctionContext.getArgument(\"varName\").replace(/\\s+/g, '').split(',');",
            "    const userDataTexts = eventsFunctionContext.getArgument(\"varText\").replace(/\\s+/g, '').split(',');",
            "    const conditionUserDataKeys = eventsFunctionContext.getArgument(\"conditionVar\").replace(/\\s+/g, '').split(',');",
            "    const conditionUserDataValues = eventsFunctionContext.getArgument(\"conditionVarText\").replace(/\\s+/g, '').split(',');",
            "",
            "    checkObjectsPositionAndSetUserData(runtimeScene, objectName, axis, value, operator, userDataPrefixes, userDataTexts, conditionUserDataKeys, conditionUserDataValues);",
            "",
            "    eventsFunctionContext.returnValue = true;",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Axis",
          "name": "axis",
          "supplementaryInformation": "[\"x\",\"y\",\"z\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Operator",
          "name": "operator",
          "supplementaryInformation": "[\"=\",\">\",\"<\",\">=\",\"<=\"]",
          "type": "stringWithSelector"
        },
        {
          "description": "Value",
          "name": "value",
          "type": "expression"
        },
        {
          "description": "conditionVar",
          "longDescription": "If instance variable name equal to text",
          "name": "conditionVar",
          "type": "string"
        },
        {
          "description": "conditionText",
          "longDescription": "Text",
          "name": "conditionVarText",
          "type": "string"
        },
        {
          "description": "Instance variable name",
          "name": "varName",
          "type": "string"
        },
        {
          "description": "Variable text",
          "name": "varText",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Is any instance collided",
      "fullName": "Is any instance collided",
      "functionType": "Condition",
      "name": "IsAnyInstanceCollided",
      "sentence": "Is any instance of: _PARAM1_ collided with _PARAM2_ ConditionVar: _PARAM3_ ConditionText: _PARAM4_ VarName: _PARAM5_ VarText: _PARAM6_ H_offset: _PARAM7_ V_offset: _PARAM8_ Invert collision: _PARAM9_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function checkObjectsCollisionAndSetUserData(runtimeScene, objectName1, objectName2, conditionUserDataKeys, conditionUserDataValues, userDataKeys, userDataValues, invertCollision, horizontalOffset, verticalOffset) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const object1 = runtimeScene.getObjects(objectName1)[0];",
            "    const object2 = runtimeScene.getObjects(objectName2)[0];",
            "    const threeObject1 = threeScene.getObjectByName(objectName1);",
            "    const threeObject2 = threeScene.getObjectByName(objectName2);",
            "",
            "    const isInstancedMesh = (obj) => obj.isInstancedMesh;",
            "",
            "    const getGDevelopObjectBox = (obj) => ({",
            "        position: new THREE.Vector3(obj.getX(), obj.getY() * -1, obj.getZ()),",
            "        width: obj.getWidth() + horizontalOffset,",
            "        height: obj.getHeight(),",
            "        depth: obj.getDepth() + verticalOffset",
            "    });",
            "",
            "    const getInstancedMeshBox = (instancedMesh, index) => {",
            "        const matrix = new THREE.Matrix4();",
            "        instancedMesh.getMatrixAt(index, matrix);",
            "",
            "        const position = new THREE.Vector3();",
            "        const quaternion = new THREE.Quaternion();",
            "        const scale = new THREE.Vector3();",
            "        matrix.decompose(position, quaternion, scale);",
            "",
            "        const bbox = instancedMesh.geometry.boundingBox.clone();",
            "        bbox.applyMatrix4(matrix);",
            "",
            "        return {",
            "            position: new THREE.Vector3(position.x, position.y * -1, position.z),",
            "            width: bbox.max.x - bbox.min.x + horizontalOffset,",
            "            height: bbox.max.y - bbox.min.y,",
            "            depth: bbox.max.z - bbox.min.z + verticalOffset",
            "        };",
            "    };",
            "",
            "    const checkCollision = (box1, box2) => {",
            "        const box1Min = box1.position.clone().sub(new THREE.Vector3(box1.width / 2, box1.height / 2, box1.depth / 2));",
            "        const box1Max = box1.position.clone().add(new THREE.Vector3(box1.width / 2, box1.height / 2, box1.depth / 2));",
            "",
            "        const box2Min = box2.position.clone().sub(new THREE.Vector3(box2.width / 2, box2.height / 2, box2.depth / 2));",
            "        const box2Max = box2.position.clone().add(new THREE.Vector3(box2.width / 2, box2.height / 2, box2.depth / 2));",
            "",
            "        return !(",
            "            box1Max.x < box2Min.x ||",
            "            box1Min.x > box2Max.x ||",
            "            box1Max.y < box2Min.y ||",
            "            box1Min.y > box2Max.y ||",
            "            box1Max.z < box2Min.z ||",
            "            box1Min.z > box2Max.z",
            "        );",
            "    };",
            "",
            "    const setUserData = (mesh, index, keys, values) => {",
            "        if (!mesh.userData) {",
            "            mesh.userData = {};",
            "        }",
            "        if (!mesh.userData[index]) {",
            "            mesh.userData[index] = {};",
            "        }",
            "        keys.forEach((key, i) => {",
            "            mesh.userData[index][key] = values[i % values.length];",
            "        });",
            "    };",
            "",
            "    const normalizeValue = (value) => {",
            "        return value === undefined || value === \"\" || value === \"0\" ? \"0\" : value;",
            "    };",
            "",
            "    const processInstancedMeshCollision = (instancedMesh, otherObject, isOtherInstanced) => {",
            "        for (let i = 0; i < instancedMesh.count; i++) {",
            "            const box1 = getInstancedMeshBox(instancedMesh, i);",
            "            let collisionDetected = false;",
            "",
            "            if (isOtherInstanced) {",
            "                for (let j = 0; j < otherObject.count; j++) {",
            "                    const box2 = getInstancedMeshBox(otherObject, j);",
            "                    if (checkCollision(box1, box2)) {",
            "                        collisionDetected = true;",
            "                        break;",
            "                    }",
            "                }",
            "            } else {",
            "                const box2 = getGDevelopObjectBox(otherObject);",
            "                if (checkCollision(box1, box2)) {",
            "                    collisionDetected = true;",
            "                }",
            "            }",
            "",
            "            if (collisionDetected !== invertCollision) {",
            "                const conditionResults = conditionUserDataKeys.every((key, index) => {",
            "                    const conditionValue = instancedMesh.userData[i][key] || \"0\";",
            "                    return normalizeValue(conditionValue) === normalizeValue(conditionUserDataValues[index % conditionUserDataValues.length]);",
            "                });",
            "",
            "                if (conditionResults) {",
            "                    setUserData(instancedMesh, i, userDataKeys, userDataValues);",
            "                }",
            "            }",
            "        }",
            "    };",
            "",
            "    const processGDevelopObjectCollision = (gdevelopObject, otherObject, isOtherInstanced) => {",
            "        const box1 = getGDevelopObjectBox(gdevelopObject);",
            "        let collisionDetected = false;",
            "",
            "        if (isOtherInstanced) {",
            "            for (let j = 0; j < otherObject.count; j++) {",
            "                const box2 = getInstancedMeshBox(otherObject, j);",
            "                if (checkCollision(box1, box2)) {",
            "                    collisionDetected = true;",
            "                    break;",
            "                }",
            "            }",
            "        } else {",
            "            const box2 = getGDevelopObjectBox(otherObject);",
            "            if (checkCollision(box1, box2)) {",
            "                collisionDetected = true;",
            "            }",
            "        }",
            "",
            "        if (collisionDetected !== invertCollision) {",
            "            const conditionResults = conditionUserDataKeys.every((key, index) => {",
            "                const conditionValue = threeObject1.userData[key] || \"0\";",
            "                return normalizeValue(conditionValue) === normalizeValue(conditionUserDataValues[index % conditionUserDataValues.length]);",
            "            });",
            "",
            "            if (conditionResults) {",
            "                userDataKeys.forEach((key, i) => {",
            "                    threeObject1.userData[key] = userDataValues[i % userDataValues.length];",
            "                });",
            "            }",
            "        }",
            "    };",
            "",
            "    if (isInstancedMesh(threeObject1)) {",
            "        processInstancedMeshCollision(threeObject1, isInstancedMesh(threeObject2) ? threeObject2 : object2, isInstancedMesh(threeObject2));",
            "    } else {",
            "        processGDevelopObjectCollision(object1, isInstancedMesh(threeObject2) ? threeObject2 : object2, isInstancedMesh(threeObject2));",
            "    }",
            "}",
            "",
            "if (objects.length > 0) {",
            "    const objectName1 = objects[0].getName();",
            "    const objectName2 = eventsFunctionContext.getArgument(\"targetMesh\");",
            "    const conditionUserDataKeys = eventsFunctionContext.getArgument(\"conditionVar\").replace(/\\s+/g, '').split(',');",
            "    const conditionUserDataValues = eventsFunctionContext.getArgument(\"conditionVarText\").replace(/\\s+/g, '').split(',');",
            "    const userDataKeys = eventsFunctionContext.getArgument(\"varName\").replace(/\\s+/g, '').split(',');",
            "    const userDataValues = eventsFunctionContext.getArgument(\"varText\").replace(/\\s+/g, '').split(',');",
            "    const invertCollision = eventsFunctionContext.getArgument(\"invertCollision\");",
            "    const horizontalOffset = parseFloat(eventsFunctionContext.getArgument(\"horizontalOffset\"));",
            "    const verticalOffset = parseFloat(eventsFunctionContext.getArgument(\"verticalOffset\"));",
            "",
            "    checkObjectsCollisionAndSetUserData(runtimeScene, objectName1, objectName2, conditionUserDataKeys, conditionUserDataValues, userDataKeys, userDataValues, invertCollision, horizontalOffset, verticalOffset);",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [
        {
          "description": "Name of instanced mesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Object to detect collision with",
          "name": "targetMesh",
          "type": "string"
        },
        {
          "description": "conditionVar",
          "longDescription": "If instance variable name equal to text",
          "name": "conditionVar",
          "type": "string"
        },
        {
          "description": "conditionText",
          "longDescription": "Text",
          "name": "conditionVarText",
          "type": "string"
        },
        {
          "description": "Instance variable name",
          "name": "varName",
          "type": "string"
        },
        {
          "description": "Variable text",
          "name": "varText",
          "type": "string"
        },
        {
          "description": "Horizontal collision offset",
          "name": "horizontalOffset",
          "type": "expression"
        },
        {
          "description": "Vertical collision offset",
          "name": "verticalOffset",
          "type": "expression"
        },
        {
          "defaultValue": "False",
          "description": "Invert Collision",
          "name": "invertCollision",
          "optional": true,
          "type": "trueorfalse"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Does InstancedMesh exist",
      "fullName": "Does InstancedMesh exist",
      "functionType": "Condition",
      "name": "IsNameExists",
      "sentence": "Does InstancedMesh exist : _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function doesInstancedMeshExist(runtimeScene, meshName) {",
            " ",
            "    var instancedMesh = runtimeScene.getLayer('').getRenderer().getThreeScene().getObjectByName(meshName);",
            "",
            "",
            "    return instancedMesh !== undefined && instancedMesh.isInstancedMesh;",
            "}",
            "",
            "var meshExists = doesInstancedMeshExist(runtimeScene, eventsFunctionContext.getArgument(\"id\"));",
            "eventsFunctionContext.returnValue = meshExists;"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the InstancedMesh",
          "name": "id",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Size of Instances",
      "fullName": "Size of Instances",
      "functionType": "ExpressionAndCondition",
      "name": "IsSize",
      "sentence": "Size of Instances of: _PARAM1_ from : _PARAM2_ to : _PARAM3_ Size : _PARAM4_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getInstancedMeshDimensionOfRange(runtimeScene, meshName, dimensionComponent, startIndex, endIndex) {",
            "    var instancedMesh = runtimeScene.getLayer('').getRenderer().getThreeScene().getObjectByName(meshName);",
            "    var dimensionValue = 0;",
            "",
            "    if (instancedMesh && instancedMesh.isInstancedMesh) {",
            "        endIndex = Math.min(endIndex, instancedMesh.count - 1);",
            "",
            "        if (startIndex >= 0 && startIndex <= endIndex) {",
            "            var matrix = new THREE.Matrix4();",
            "            instancedMesh.getMatrixAt(startIndex, matrix);",
            "            var position = new THREE.Vector3();",
            "            var quaternion = new THREE.Quaternion();",
            "            var scale = new THREE.Vector3();",
            "            matrix.decompose(position, quaternion, scale);",
            "",
            "   ",
            "            switch (dimensionComponent) {",
            "                case 'width': dimensionValue = scale.x; break;",
            "                case 'height': dimensionValue = scale.y; break;",
            "                case 'depth': dimensionValue = scale.z; break;",
            "            }",
            "        }",
            "    }",
            "",
            "",
            "    return dimensionValue;",
            "}",
            "",
            "var dimensionComponent = eventsFunctionContext.getArgument(\"size\");",
            "var sizeType = \"\"; ",
            "",
            "",
            "if (dimensionComponent instanceof gdjs.Variable) {",
            "    if (dimensionComponent.hasChild(\"width\")) {",
            "        sizeType = \"width\";",
            "    } else if (dimensionComponent.hasChild(\"height\")) {",
            "        sizeType = \"height\";",
            "    } else if (dimensionComponent.hasChild(\"depth\")) {",
            "        sizeType = \"depth\";",
            "    }",
            "}",
            "",
            "var dimension = getInstancedMeshDimensionOfRange(",
            "    runtimeScene,",
            "    eventsFunctionContext.getArgument(\"id\"),",
            "    sizeType,",
            "    eventsFunctionContext.getArgument(\"startIndex\"),",
            "    eventsFunctionContext.getArgument(\"endIndex\")",
            ");",
            "",
            "eventsFunctionContext.returnValue = dimension;"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Name of the InstancedMesh",
          "name": "id",
          "type": "string"
        },
        {
          "description": "Start Index",
          "name": "startIndex",
          "type": "expression"
        },
        {
          "description": "End Index",
          "name": "endIndex",
          "type": "expression"
        },
        {
          "description": "Size of instances",
          "name": "size",
          "supplementaryInformation": "[\"width\",\"height\",\"depth\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Amount of instances check",
      "fullName": "Amount of instances check",
      "functionType": "ExpressionAndCondition",
      "name": "IsAmountOfInstances",
      "sentence": "Amount of instances: _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getInstancedMeshInstanceCount(runtimeScene, meshName) {",
            "",
            "    var instancedMesh = runtimeScene.getLayer('').getRenderer().getThreeScene().getObjectByName(meshName);",
            "",
            "",
            "    return instancedMesh && instancedMesh.isInstancedMesh ? instancedMesh.count : 0;",
            "}",
            "",
            "var instanceCount = getInstancedMeshInstanceCount(runtimeScene, eventsFunctionContext.getArgument(\"id\"));",
            "eventsFunctionContext.returnValue = instanceCount;"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Name of the InstancedMesh",
          "name": "id",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Ray intersected",
      "fullName": "Ray intersected",
      "functionType": "ExpressionAndCondition",
      "name": "IsRayIntersected",
      "sentence": "Ray intersected Ray name: _PARAM1_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function hasIntersection(runtimeScene, rayName) {",
            "    var raycastingVar = runtimeScene.getVariables().get(\"_raycasting_instanced_mesh\");",
            "",
            "    var intersected = raycastingVar.getChildNamed(rayName+\"intersected\").getAsString();",
            "",
            "    if (intersected === \"true\") {",
            "      return true;",
            "    } else {",
            "      return false;",
            "    }",
            "}",
            "",
            "var intersectionExists = hasIntersection(runtimeScene, eventsFunctionContext.getArgument(\"rayName\"));",
            "eventsFunctionContext.returnValue = intersectionExists;"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "supplementaryInformation": "[\"true\",\"false\"]",
        "type": "stringWithSelector"
      },
      "parameters": [
        {
          "description": "Ray name",
          "name": "rayName",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Ray intersect position",
      "fullName": "Ray intersect position",
      "functionType": "ExpressionAndCondition",
      "name": "IsRayIntersectedPosition",
      "sentence": "Ray intersect position Ray name: _PARAM1_ Axis: _PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getIntersectionPointOfRay(runtimeScene, rayName, axis) {",
            "    var threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "",
            "    if (!threeScene.raycasterMap) {",
            "        threeScene.raycasterMap = new Map();",
            "    }",
            "",
            "    var raycasterMap = threeScene.raycasterMap;",
            "",
            "    if (raycasterMap.has(rayName)) {",
            "        var raycaster = raycasterMap.get(rayName);",
            "        var instancedMeshIntersects = [];",
            "",
            "        threeScene.traverse((child) => {",
            "            if (child.isMesh) {",
            "                var intersects = raycaster.intersectObject(child, true);",
            "                intersects.forEach((intersect) => {",
            "                    instancedMeshIntersects.push(intersect);",
            "                });",
            "            }",
            "        });",
            "",
            "        instancedMeshIntersects.sort((a, b) => a.distance - b.distance);",
            "",
            "        if (instancedMeshIntersects.length > 0) {",
            "            return instancedMeshIntersects[0].point[axis];",
            "        }",
            "    }",
            "",
            "    return 0;",
            "}",
            "",
            "var pointComponent = getIntersectionPointOfRay(runtimeScene, eventsFunctionContext.getArgument(\"rayName\"), eventsFunctionContext.getArgument(\"axis\"));",
            "eventsFunctionContext.returnValue = pointComponent;"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Ray name",
          "name": "rayName",
          "type": "string"
        },
        {
          "description": "Axis",
          "name": "axis",
          "supplementaryInformation": "[\"x\",\"y\",\"z\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Ray intersect distance",
      "fullName": "Ray intersect distance",
      "functionType": "ExpressionAndCondition",
      "name": "IsRayIntersectedDistance",
      "sentence": "Ray intersect distance Ray name: _PARAM1_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getIntersectionDistanceOfRay(runtimeScene, rayName) {",
            "    var threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "",
            "    if (!threeScene.raycasterMap) {",
            "        threeScene.raycasterMap = new Map();",
            "    }",
            "",
            "    var raycasterMap = threeScene.raycasterMap;",
            "",
            "    if (raycasterMap.has(rayName)) {",
            "        var raycaster = raycasterMap.get(rayName);",
            "        var instancedMeshIntersects = [];",
            "        threeScene.traverse((child) => {",
            "            if (child.isMesh) {",
            "                var intersects = raycaster.intersectObject(child, true);",
            "                intersects.forEach((intersect) => {",
            "                    instancedMeshIntersects.push(intersect);",
            "                });",
            "            }",
            "        });",
            "",
            "        instancedMeshIntersects.sort((a, b) => a.distance - b.distance);",
            "",
            "        if (instancedMeshIntersects.length > 0) {",
            "            return instancedMeshIntersects[0].distance;",
            "        }",
            "    }",
            "",
            "    return 0;",
            "}",
            "",
            "var distance = getIntersectionDistanceOfRay(runtimeScene, eventsFunctionContext.getArgument(\"rayName\"));",
            "eventsFunctionContext.returnValue = distance;"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Ray name",
          "name": "rayName",
          "type": "string"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Distance between positions",
      "fullName": "Distance between positions",
      "functionType": "ExpressionAndCondition",
      "name": "IsDistancePositions",
      "sentence": "Distance between positions X1: _PARAM1_ Y1: _PARAM2_  Z1: _PARAM3_ X2: _PARAM4_ Y2: _PARAM5_ Z2: _PARAM6_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getDistanceBetweenPositions(x1, y1, z1, x2, y2, z2) {",
            "",
            "    const position1 = new THREE.Vector3(x1, y1, z1);",
            "    const position2 = new THREE.Vector3(x2, y2, z2);",
            "",
            " ",
            "    const distance = position1.distanceTo(position2);",
            "",
            " ",
            "    return distance;",
            "}",
            "",
            "",
            "const x1 = parseFloat(eventsFunctionContext.getArgument(\"x1\"));",
            "const y1 = parseFloat(eventsFunctionContext.getArgument(\"y1\"));",
            "const z1 = parseFloat(eventsFunctionContext.getArgument(\"z1\"));",
            "const x2 = parseFloat(eventsFunctionContext.getArgument(\"x2\"));",
            "const y2 = parseFloat(eventsFunctionContext.getArgument(\"y2\"));",
            "const z2 = parseFloat(eventsFunctionContext.getArgument(\"z2\"));",
            "",
            "",
            "const distance = getDistanceBetweenPositions(x1, y1, z1, x2, y2, z2);",
            "eventsFunctionContext.returnValue = distance;"
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "First X",
          "name": "x1",
          "type": "expression"
        },
        {
          "description": "First Y",
          "name": "y1",
          "type": "expression"
        },
        {
          "description": "First Z",
          "name": "z1",
          "type": "expression"
        },
        {
          "description": "Second X",
          "name": "x2",
          "type": "expression"
        },
        {
          "description": "Second Y",
          "name": "y2",
          "type": "expression"
        },
        {
          "description": "Second Z",
          "name": "z2",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Position of bone",
      "fullName": "Position of bone",
      "functionType": "ExpressionAndCondition",
      "name": "IsPositionOfBone",
      "sentence": "Position of bone of : _PARAM1_  Name: _PARAM2_  Axis: _PARAM3_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getBoneWorldPosition(runtimeScene, objectName, boneName, positionComponent) {",
            "    var threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    var object = threeScene.getObjectByName(objectName);",
            "",
            "    if (!object) {",
            "        return 0;",
            "    }",
            "",
            "    var findBoneByName = function (obj, name) {",
            "        if (obj.isBone && obj.name === name) {",
            "            return obj;",
            "        }",
            "        for (let child of obj.children) {",
            "            const found = findBoneByName(child, name);",
            "            if (found) return found;",
            "        }",
            "        return null;",
            "    };",
            "",
            "    var bone = findBoneByName(object, boneName);",
            "",
            "    if (!bone) {",
            "        return 0;",
            "    }",
            "",
            "    var worldPosition = new THREE.Vector3();",
            "    bone.getWorldPosition(worldPosition);",
            "",
            "    return worldPosition[positionComponent];",
            "}",
            "",
            "var positionComponent = getBoneWorldPosition(",
            "    runtimeScene,",
            "    eventsFunctionContext.getArgument(\"id\"),",
            "    eventsFunctionContext.getArgument(\"boneName\"),",
            "    eventsFunctionContext.getArgument(\"Position\")",
            ");",
            "",
            "eventsFunctionContext.returnValue = positionComponent;",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Name of the Mesh",
          "name": "id",
          "type": "string"
        },
        {
          "description": "Bone name",
          "name": "boneName",
          "type": "string"
        },
        {
          "description": "Pick X/Y/Z",
          "name": "Position",
          "supplementaryInformation": "[\"x\",\"y\",\"z\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Position of instances",
      "fullName": "Position of instances",
      "functionType": "ExpressionAndCondition",
      "name": "IsPositionOfInstance",
      "sentence": "Position of: _PARAM1_  Index: _PARAM2_  Axis: _PARAM3_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getMeshInstancePosition(runtimeScene, meshName, positionComponent, instanceIndex) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const mesh = threeScene.getObjectByName(meshName);",
            "",
            "    if (mesh) {",
            "        if (mesh.isInstancedMesh) {",
            "            if (instanceIndex >= 0 && instanceIndex < mesh.count) {",
            "                var matrix = new THREE.Matrix4();",
            "                mesh.getMatrixAt(instanceIndex, matrix);",
            "                var position = new THREE.Vector3();",
            "                var quaternion = new THREE.Quaternion();",
            "                var scale = new THREE.Vector3();",
            "                matrix.decompose(position, quaternion, scale);",
            "                return position[positionComponent];",
            "            }",
            "        } else {",
            "            let regularMeshes = [];",
            "            threeScene.traverse((child) => {",
            "                if (child.isMesh && child.name === meshName) {",
            "                    regularMeshes.push(child);",
            "                }",
            "            });",
            "            if (instanceIndex >= 0 && instanceIndex < regularMeshes.length) {",
            "                const specificMesh = regularMeshes[instanceIndex];",
            "                const position = new THREE.Vector3();",
            "                specificMesh.getWorldPosition(position);",
            "                return position[positionComponent];",
            "            }",
            "        }",
            "    }",
            "    return 0;",
            "}",
            "",
            "if (objects.length > 0) {",
            "    var positionComponent = eventsFunctionContext.getArgument(\"Position\");",
            "    var instanceIndex = parseInt(eventsFunctionContext.getArgument(\"index\"));",
            "    var position = getMeshInstancePosition(runtimeScene, objects[0].getName(), positionComponent, instanceIndex);",
            "    eventsFunctionContext.returnValue = position;",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Name of the InstancedMesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Instance index",
          "name": "index",
          "type": "expression"
        },
        {
          "description": "Pick X/Y/Z",
          "name": "Position",
          "supplementaryInformation": "[\"x\",\"y\",\"z\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Scale of instances",
      "fullName": "Scale of instances",
      "functionType": "ExpressionAndCondition",
      "name": "IsScaleOfInstance",
      "sentence": "Scale of instances: _PARAM1_  Index: _PARAM2_  Axis: _PARAM3_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getMeshInstanceScale(runtimeScene, meshName, scaleComponent, instanceIndex) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const mesh = threeScene.getObjectByName(meshName);",
            "",
            "    if (mesh) {",
            "        if (mesh.isInstancedMesh) {",
            "            if (instanceIndex >= 0 && instanceIndex < mesh.count) {",
            "                var matrix = new THREE.Matrix4();",
            "                mesh.getMatrixAt(instanceIndex, matrix);",
            "                var position = new THREE.Vector3();",
            "                var quaternion = new THREE.Quaternion();",
            "                var scale = new THREE.Vector3();",
            "                matrix.decompose(position, quaternion, scale);",
            "                return scale[scaleComponent];",
            "            }",
            "        } else {",
            "            let regularMeshes = [];",
            "            threeScene.traverse((child) => {",
            "                if (child.isMesh && child.name === meshName) {",
            "                    regularMeshes.push(child);",
            "                }",
            "            });",
            "            if (instanceIndex >= 0 && instanceIndex < regularMeshes.length) {",
            "                const specificMesh = regularMeshes[instanceIndex];",
            "                const scale = new THREE.Vector3();",
            "                specificMesh.getWorldScale(scale);",
            "                return scale[scaleComponent];",
            "            }",
            "        }",
            "    }",
            "",
            "    return 0;",
            "}",
            "",
            "if (objects.length > 0) {",
            "    var scaleComponent = eventsFunctionContext.getArgument(\"Scale\");",
            "    var instanceIndex = parseInt(eventsFunctionContext.getArgument(\"index\"));",
            "    var scale = getMeshInstanceScale(runtimeScene, objects[0].getName(), scaleComponent, instanceIndex);",
            "    eventsFunctionContext.returnValue = scale;",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Name",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Instance index",
          "name": "index",
          "type": "expression"
        },
        {
          "description": "Scale axis",
          "name": "Scale",
          "supplementaryInformation": "[\"x\",\"y\",\"z\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Rotation of instances ",
      "fullName": "Rotation of instances ",
      "functionType": "ExpressionAndCondition",
      "name": "IsRotationOfInstance",
      "sentence": "Rotation of instances  : _PARAM1_  Index: _PARAM2_  Angle: _PARAM3_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getMeshInstanceAngle(runtimeScene, meshName, angleComponent, instanceIndex) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const mesh = threeScene.getObjectByName(meshName);",
            "",
            "    if (mesh) {",
            "        if (mesh.isInstancedMesh) {",
            "            if (instanceIndex >= 0 && instanceIndex < mesh.count) {",
            "                var matrix = new THREE.Matrix4();",
            "                mesh.getMatrixAt(instanceIndex, matrix);",
            "                var position = new THREE.Vector3();",
            "                var quaternion = new THREE.Quaternion();",
            "                var scale = new THREE.Vector3();",
            "                matrix.decompose(position, quaternion, scale);",
            "                var euler = new THREE.Euler().setFromQuaternion(quaternion, 'ZYX');",
            "                var angle = euler[angleComponent] * (180 / Math.PI); // Convert radians to degrees",
            "                return angle;",
            "            }",
            "        } else {",
            "            let regularMeshes = [];",
            "            threeScene.traverse((child) => {",
            "                if (child.isMesh && child.name === meshName) {",
            "                    regularMeshes.push(child);",
            "                }",
            "            });",
            "            if (instanceIndex >= 0 && instanceIndex < regularMeshes.length) {",
            "                const specificMesh = regularMeshes[instanceIndex];",
            "                const quaternion = specificMesh.quaternion;",
            "                var euler = new THREE.Euler().setFromQuaternion(quaternion, 'ZYX');",
            "                var angle = euler[angleComponent] * (180 / Math.PI); // Convert radians to degrees",
            "                return angle;",
            "            }",
            "        }",
            "    }",
            "    return 0;",
            "}",
            "",
            "if (objects.length > 0) {",
            "    var angleComponent = eventsFunctionContext.getArgument(\"Angle\");",
            "    var instanceIndex = parseInt(eventsFunctionContext.getArgument(\"index\"));",
            "    var angle = getMeshInstanceAngle(runtimeScene, objects[0].getName(), angleComponent, instanceIndex);",
            "    eventsFunctionContext.returnValue = angle;",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Name of the InstancedMesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Instance index",
          "name": "index",
          "type": "expression"
        },
        {
          "description": "Rotation axis",
          "name": "Angle",
          "supplementaryInformation": "[\"x\",\"y\",\"z\"]",
          "type": "stringWithSelector"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Opacity of the mesh",
      "fullName": "Opacity of the mesh",
      "functionType": "ExpressionAndCondition",
      "name": "IsOpacityOfMesh",
      "sentence": "Opacity of the mesh  : _PARAM1_  Index: _PARAM2_  ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getMeshOpacity(runtimeScene, meshName, index) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const mesh = threeScene.getObjectByName(meshName);",
            "",
            "    if (mesh) {",
            "        if (mesh.isInstancedMesh) {",
            "            if (index >= 0 && index < mesh.count) {",
            "",
            "                if (mesh.material && 'opacity' in mesh.material) {",
            "                    return mesh.material.opacity;",
            "                }",
            "            }",
            "        } else {",
            "",
            "            let regularMeshes = [];",
            "            threeScene.traverse((child) => {",
            "                if (child.isMesh && child.name === meshName) {",
            "                    regularMeshes.push(child);",
            "                }",
            "            });",
            "",
            "            if (index >= 0 && index < regularMeshes.length) {",
            "                const specificMesh = regularMeshes[index];",
            "                if (specificMesh.material && 'opacity' in specificMesh.material) {",
            "                    return specificMesh.material.opacity;",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    return 0;",
            "}",
            "",
            "if (objects.length > 0) {",
            "    const index = parseInt(eventsFunctionContext.getArgument(\"index\"));",
            "    const opacity = getMeshOpacity(runtimeScene, objects[0].getName(), index);",
            "    eventsFunctionContext.returnValue = opacity;",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Name of the InstancedMesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Index of the instance",
          "name": "index",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Instance Width",
      "fullName": "Instance Width",
      "functionType": "ExpressionAndCondition",
      "name": "IsInstanceWidth",
      "sentence": "Instance Width of: _PARAM1_  : _PARAM2_  ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getMeshInstanceWidth(runtimeScene, meshName, instanceIndex) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const mesh = threeScene.getObjectByName(meshName);",
            "",
            "    if (mesh) {",
            "        if (mesh.isInstancedMesh) {",
            "            if (!mesh.geometry.boundingBox) {",
            "                mesh.geometry.computeBoundingBox();",
            "            }",
            "            const boundingBox = mesh.geometry.boundingBox.clone();",
            "            const matrix = new THREE.Matrix4();",
            "            mesh.getMatrixAt(instanceIndex, matrix);",
            "            boundingBox.applyMatrix4(matrix);",
            "            return boundingBox.max.x - boundingBox.min.x;",
            "        } else {",
            "            let regularMeshes = [];",
            "            threeScene.traverse((child) => {",
            "                if (child.isMesh && child.name === meshName) {",
            "                    regularMeshes.push(child);",
            "                }",
            "            });",
            "            if (instanceIndex >= 0 && instanceIndex < regularMeshes.length) {",
            "                const specificMesh = regularMeshes[instanceIndex];",
            "                if (!specificMesh.geometry.boundingBox) {",
            "                    specificMesh.geometry.computeBoundingBox();",
            "                }",
            "                const boundingBox = specificMesh.geometry.boundingBox.clone();",
            "                boundingBox.applyMatrix4(specificMesh.matrixWorld);",
            "                return boundingBox.max.x - boundingBox.min.x;",
            "            }",
            "        }",
            "    }",
            "    return 0;",
            "}",
            "",
            "if (objects.length > 0) {",
            "    var meshName = objects[0].getName();",
            "    var instanceIndex = eventsFunctionContext.getArgument(\"index\");",
            "    var width = getMeshInstanceWidth(runtimeScene, meshName, instanceIndex);",
            "    eventsFunctionContext.returnValue = width;",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Name of the InstancedMesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Index of the instance",
          "name": "index",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Instance Height",
      "fullName": "Instance Height",
      "functionType": "ExpressionAndCondition",
      "name": "IsInstanceHeight",
      "sentence": "Instance Height of : _PARAM1_  : _PARAM2_  ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getMeshInstanceHeight(runtimeScene, meshName, instanceIndex) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const mesh = threeScene.getObjectByName(meshName);",
            "",
            "    if (mesh) {",
            "        if (mesh.isInstancedMesh) {",
            "            if (!mesh.geometry.boundingBox) {",
            "                mesh.geometry.computeBoundingBox();",
            "            }",
            "            const boundingBox = mesh.geometry.boundingBox.clone();",
            "            const matrix = new THREE.Matrix4();",
            "            mesh.getMatrixAt(instanceIndex, matrix);",
            "            boundingBox.applyMatrix4(matrix);",
            "            return boundingBox.max.y - boundingBox.min.y;",
            "        } else {",
            "            let regularMeshes = [];",
            "            threeScene.traverse((child) => {",
            "                if (child.isMesh && child.name === meshName) {",
            "                    regularMeshes.push(child);",
            "                }",
            "            });",
            "            if (instanceIndex >= 0 && instanceIndex < regularMeshes.length) {",
            "                const specificMesh = regularMeshes[instanceIndex];",
            "                if (!specificMesh.geometry.boundingBox) {",
            "                    specificMesh.geometry.computeBoundingBox();",
            "                }",
            "                const boundingBox = specificMesh.geometry.boundingBox.clone();",
            "                boundingBox.applyMatrix4(specificMesh.matrixWorld);",
            "                return boundingBox.max.y - boundingBox.min.y;",
            "            }",
            "        }",
            "    }",
            "    return 0;",
            "}",
            "",
            "if (objects.length > 0) {",
            "    var meshName = objects[0].getName();",
            "    var instanceIndex = eventsFunctionContext.getArgument(\"index\");",
            "    var height = getMeshInstanceHeight(runtimeScene, meshName, instanceIndex);",
            "    eventsFunctionContext.returnValue = height;",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Name of the InstancedMesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Index of the instance",
          "name": "index",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Instance Depth",
      "fullName": "Instance Depth",
      "functionType": "ExpressionAndCondition",
      "name": "IsInstanceDepth",
      "sentence": "Instance Depth of: _PARAM1_  : _PARAM2_  ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "function getMeshInstanceDepth(runtimeScene, meshName, instanceIndex) {",
            "    const threeScene = runtimeScene.getLayer('').getRenderer().getThreeScene();",
            "    const mesh = threeScene.getObjectByName(meshName);",
            "",
            "    if (mesh) {",
            "        if (mesh.isInstancedMesh) {",
            "            if (!mesh.geometry.boundingBox) {",
            "                mesh.geometry.computeBoundingBox();",
            "            }",
            "            const boundingBox = mesh.geometry.boundingBox.clone();",
            "            const matrix = new THREE.Matrix4();",
            "            mesh.getMatrixAt(instanceIndex, matrix);",
            "            boundingBox.applyMatrix4(matrix);",
            "            return boundingBox.max.z - boundingBox.min.z;",
            "        } else {",
            "            let regularMeshes = [];",
            "            threeScene.traverse((child) => {",
            "                if (child.isMesh && child.name === meshName) {",
            "                    regularMeshes.push(child);",
            "                }",
            "            });",
            "            if (instanceIndex >= 0 && instanceIndex < regularMeshes.length) {",
            "                const specificMesh = regularMeshes[instanceIndex];",
            "                if (!specificMesh.geometry.boundingBox) {",
            "                    specificMesh.geometry.computeBoundingBox();",
            "                }",
            "                const boundingBox = specificMesh.geometry.boundingBox.clone();",
            "                boundingBox.applyMatrix4(specificMesh.matrixWorld);",
            "                return boundingBox.max.z - boundingBox.min.z;",
            "            }",
            "        }",
            "    }",
            "    return 0;",
            "}",
            "",
            "if (objects.length > 0) {",
            "    var meshName = objects[0].getName();",
            "    var instanceIndex = eventsFunctionContext.getArgument(\"index\");",
            "    var depth = getMeshInstanceDepth(runtimeScene, meshName, instanceIndex);",
            "    eventsFunctionContext.returnValue = depth;",
            "}"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Name of the InstancedMesh",
          "name": "id",
          "type": "objectList"
        },
        {
          "description": "Index of the instance",
          "name": "index",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Get instance index",
      "fullName": "Get instance index",
      "functionType": "Expression",
      "name": "IsIndex",
      "sentence": "Synchronize names for: _PARAM1_ ",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "let meshIndex = -1;",
            "",
            "if (objects.length > 0) {",
            "    let currentIndex = 0; ",
            "    objects[0].get3DRendererObject().traverse((node) => {",
            "        if (node.isMesh) {",
            "            if (meshIndex === -1) {",
            "                meshIndex = currentIndex;",
            "            }",
            "            currentIndex++; ",
            "        }",
            "    });",
            "}",
            "",
            "eventsFunctionContext.returnValue = meshIndex;"
          ],
          "parameterObjects": "id",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [
        {
          "description": "Mesh",
          "name": "id",
          "type": "objectList"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": [
    {
      "defaultName": "Instanced_mesh_box",
      "description": "Instanced mesh box",
      "fullName": "Instanced mesh box",
      "is3D": true,
      "name": "InstancedMeshBox",
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onCreated",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_type",
                    "=",
                    "\"box\""
                  ]
                },
                {
                  "type": {
                    "value": "InstancedMeshRelease::DefineHelperClasses"
                  },
                  "parameters": [
                    "",
                    ""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_widthSegments",
                    "=",
                    "widthSegments"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_heightSegments",
                    "=",
                    "heightSegments"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_depthSegments",
                    "=",
                    "depthSegments"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_width",
                    "=",
                    "widthMy"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_height",
                    "=",
                    "heigthMy"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_depth",
                    "=",
                    "depthMy"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_instanceCount",
                    "=",
                    "countMy"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_offsetX",
                    "=",
                    "offsetX"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_offsetY",
                    "=",
                    "offsetY"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_offsetZ",
                    "=",
                    "offsetZ"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_horizontalMax",
                    "=",
                    "horizontalMax"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_verticalMax",
                    "=",
                    "verticalMax"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "if (!object.__box3DExtension) {",
                    "    object.__box3DExtension = {};",
                    "}",
                    "",
                    "try {",
                    "    const variables = runtimeScene.getGame().getVariables();",
                    "    const widthSegments = variables.get(\"_customThreeObject_widthSegments\").getAsNumber() || 1;",
                    "    const heightSegments = variables.get(\"_customThreeObject_heightSegments\").getAsNumber() || 1;",
                    "    const depthSegments = variables.get(\"_customThreeObject_depthSegments\").getAsNumber() || 1;",
                    "    const width = variables.get(\"_customThreeObject_width\").getAsNumber() || 10;",
                    "    const height = variables.get(\"_customThreeObject_height\").getAsNumber() || 10;",
                    "    const depth = variables.get(\"_customThreeObject_depth\").getAsNumber() || 10;",
                    "    const instanceCount = variables.get(\"_customThreeObject_instanceCount\").getAsNumber() || 1;",
                    "    const offsetX = variables.get(\"_customThreeObject_offsetX\").getAsNumber();",
                    "    const offsetY = variables.get(\"_customThreeObject_offsetY\").getAsNumber();",
                    "    const offsetZ = variables.get(\"_customThreeObject_offsetZ\").getAsNumber();",
                    "    const horizCountMax = variables.get(\"_customThreeObject_horizontalMax\").getAsNumber() || 1;",
                    "    const vertCountMax = variables.get(\"_customThreeObject_verticalMax\").getAsNumber() || 1;",
                    "",
                    "    if (!object.__box3DExtension.box3DRenderer || object.__box3DExtension.box3DRenderer.instancedMesh.count !== instanceCount) {",
                    "        object.__box3DExtension.box3DRenderer = new gdjs.__box3DExtension.Box3DRenderer(",
                    "            object, width, height, depth, instanceCount, offsetX, offsetY, offsetZ, horizCountMax, vertCountMax, widthSegments, heightSegments, depthSegments",
                    "        );",
                    "    }",
                    "} catch (error) {",
                    "    console.log(\"An error occurred:\", error.message);",
                    "}",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "InstancedMeshRelease::InstancedMeshBox",
              "type": "object"
            }
          ],
          "objectGroups": [
            {
              "name": "GroupInstancedMesh",
              "objects": [
                {
                  "name": "Object"
                }
              ]
            }
          ]
        }
      ],
      "propertyDescriptors": [
        {
          "value": "100",
          "type": "Number",
          "label": "Width",
          "description": "Width",
          "group": "Size",
          "extraInformation": [],
          "name": "widthMy"
        },
        {
          "value": "100",
          "type": "Number",
          "label": "Heigth",
          "description": "Heigth",
          "group": "Size",
          "extraInformation": [],
          "name": "heigthMy"
        },
        {
          "value": "100",
          "type": "Number",
          "label": "Depth",
          "description": "Depth",
          "group": "Size",
          "extraInformation": [],
          "name": "depthMy"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Number of box instances to create",
          "description": "Number of box instances to create",
          "group": "",
          "extraInformation": [],
          "name": "countMy"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "X space between instances",
          "description": "X space between instances",
          "group": "Offset",
          "extraInformation": [],
          "name": "offsetX"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Y space between instances",
          "description": "Y space between instances",
          "group": "Offset",
          "extraInformation": [],
          "name": "offsetY"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Z space between instances",
          "description": "Z space between instances",
          "group": "Offset",
          "extraInformation": [],
          "name": "offsetZ"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Horizontal size grid",
          "description": "Horizontal size grid",
          "group": "Grid",
          "extraInformation": [],
          "name": "horizontalMax"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Vertical size grid",
          "description": "Vertical size grid",
          "group": "Grid",
          "extraInformation": [],
          "name": "verticalMax"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Width segments",
          "description": "Width segments",
          "group": "Segments",
          "extraInformation": [],
          "name": "widthSegments"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Height segments",
          "description": "Height segments",
          "group": "Segments",
          "extraInformation": [],
          "name": "heightSegments"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Depth segments",
          "description": "Depth segments",
          "group": "Segments",
          "extraInformation": [],
          "name": "depthSegments"
        }
      ],
      "objects": [],
      "objectsFolderStructure": {
        "folderName": "__ROOT"
      }
    },
    {
      "defaultName": "Instanced_mesh_dodecahedron",
      "description": "Instanced mesh dodecahedron",
      "fullName": "Instanced mesh dodecahedron",
      "is3D": true,
      "name": "InstancedMeshDodecahedron",
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onCreated",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_type",
                    "=",
                    "\"dodecahedron\""
                  ]
                },
                {
                  "type": {
                    "value": "InstancedMeshRelease::DefineHelperClasses"
                  },
                  "parameters": [
                    "",
                    ""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_radius",
                    "=",
                    "radiusMy"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_detail",
                    "=",
                    "detailMy"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_instanceCount",
                    "=",
                    "countMy"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_offsetX",
                    "=",
                    "offsetX"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_offsetY",
                    "=",
                    "offsetY"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_offsetZ",
                    "=",
                    "offsetZ"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_horizontalMax",
                    "=",
                    "horizontalMax"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_verticalMax",
                    "=",
                    "verticalMax"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "if (!object.__dodecahedron3DExtension) {",
                    "    object.__dodecahedron3DExtension = {};",
                    "}",
                    "",
                    "try {",
                    "    const variables = runtimeScene.getGame().getVariables();",
                    "    const radius = variables.get(\"_customThreeObject_radius\").getAsNumber() || 100;",
                    "    const detail = variables.get(\"_customThreeObject_detail\").getAsNumber() || 0;",
                    "    const instanceCount = variables.get(\"_customThreeObject_instanceCount\").getAsNumber() || 1;",
                    "    const offsetX = variables.get(\"_customThreeObject_offsetX\").getAsNumber();",
                    "    const offsetY = variables.get(\"_customThreeObject_offsetY\").getAsNumber();",
                    "    const offsetZ = variables.get(\"_customThreeObject_offsetZ\").getAsNumber();",
                    "    const horizCountMax = variables.get(\"_customThreeObject_horizontalMax\").getAsNumber() || 1;",
                    "    const vertCountMax = variables.get(\"_customThreeObject_verticalMax\").getAsNumber() || 1;",
                    "",
                    "    if (!object.__dodecahedron3DExtension.dodecahedron3DRenderer || object.__dodecahedron3DExtension.dodecahedron3DRenderer.instancedMesh.count !== instanceCount) {",
                    "        object.__dodecahedron3DExtension.dodecahedron3DRenderer = new gdjs.__dodecahedron3DExtension.Dodecahedron3DRenderer(",
                    "            object, radius, detail, instanceCount, offsetX, offsetY, offsetZ, horizCountMax, vertCountMax",
                    "        );",
                    "    }",
                    "} catch (error) {",
                    "    console.log(\"An error occurred:\", error.message);",
                    "}",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "InstancedMeshRelease::InstancedMeshDodecahedron",
              "type": "object"
            }
          ],
          "objectGroups": [
            {
              "name": "Group",
              "objects": [
                {
                  "name": "Object"
                }
              ]
            }
          ]
        }
      ],
      "propertyDescriptors": [
        {
          "value": "100",
          "type": "Number",
          "label": "Radius",
          "description": "Radius",
          "group": "Size",
          "extraInformation": [],
          "name": "radiusMy"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Detail",
          "description": "Detail",
          "group": "Size",
          "extraInformation": [],
          "name": "detailMy"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Number of dodecahedron instances to create",
          "description": "Number of dodecahedron instances to create",
          "group": "",
          "extraInformation": [],
          "name": "countMy"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "X space between instances",
          "description": "X space between instances",
          "group": "Offset",
          "extraInformation": [],
          "name": "offsetX"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Y space between instances",
          "description": "Y space between instances",
          "group": "Offset",
          "extraInformation": [],
          "name": "offsetY"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Z space between instances",
          "description": "Z space between instances",
          "group": "Offset",
          "extraInformation": [],
          "name": "offsetZ"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Horizontal size grid",
          "description": "Horizontal size grid",
          "group": "Grid",
          "extraInformation": [],
          "name": "horizontalMax"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Vertical size grid",
          "description": "Vertical size grid",
          "group": "Grid",
          "extraInformation": [],
          "name": "verticalMax"
        }
      ],
      "objects": [],
      "objectsFolderStructure": {
        "folderName": "__ROOT"
      }
    },
    {
      "defaultName": "Instanced_mesh_sphere",
      "description": "Instanced mesh sphere",
      "fullName": "Instanced mesh sphere",
      "is3D": true,
      "name": "InstancedMeshSphere",
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onCreated",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_type",
                    "=",
                    "\"sphere\""
                  ]
                },
                {
                  "type": {
                    "value": "InstancedMeshRelease::DefineHelperClasses"
                  },
                  "parameters": [
                    "",
                    ""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_radius",
                    "=",
                    "radiusMy"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_widthSegments",
                    "=",
                    "widthSegments"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_heightSegments",
                    "=",
                    "heightSegments"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_phiStart",
                    "=",
                    "phiStart"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_phiLength",
                    "=",
                    "phiLength"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_thetaStart",
                    "=",
                    "thetaStart"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_thetaLength",
                    "=",
                    "thetaLength"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_instanceCount",
                    "=",
                    "countMy"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_offsetX",
                    "=",
                    "offsetX"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_offsetY",
                    "=",
                    "offsetY"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_offsetZ",
                    "=",
                    "offsetZ"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_horizontalMax",
                    "=",
                    "horizontalMax"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_verticalMax",
                    "=",
                    "verticalMax"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "if (!object.__sphere3DExtension) {",
                    "    object.__sphere3DExtension = {};",
                    "}",
                    "",
                    "try {",
                    "    const variables = runtimeScene.getGame().getVariables();",
                    "    const radius = variables.get(\"_customThreeObject_radius\").getAsNumber() || 100;",
                    "    const widthSegments = variables.get(\"_customThreeObject_widthSegments\").getAsNumber() || 16;",
                    "    const heightSegments = variables.get(\"_customThreeObject_heightSegments\").getAsNumber() || 16;",
                    "    const phiStart = variables.get(\"_customThreeObject_phiStart\").getAsNumber() || 0;",
                    "    const phiLength = variables.get(\"_customThreeObject_phiLength\").getAsNumber() || 7;",
                    "    const thetaStart = variables.get(\"_customThreeObject_thetaStart\").getAsNumber() || 0;",
                    "    const thetaLength = variables.get(\"_customThreeObject_thetaLength\").getAsNumber() || 7;",
                    "    const instanceCount = variables.get(\"_customThreeObject_instanceCount\").getAsNumber() || 1;",
                    "    const offsetX = variables.get(\"_customThreeObject_offsetX\").getAsNumber();",
                    "    const offsetY = variables.get(\"_customThreeObject_offsetY\").getAsNumber();",
                    "    const offsetZ = variables.get(\"_customThreeObject_offsetZ\").getAsNumber();",
                    "    const maxYCount = variables.get(\"_customThreeObject_horizontalMax\").getAsNumber() || 1;",
                    "    const maxZCount = variables.get(\"_customThreeObject_verticalMax\").getAsNumber() || 1;",
                    "",
                    "    if (!object.__sphere3DExtension.sphere3DRenderer || object.__sphere3DExtension.sphere3DRenderer.instancedMesh.count !== instanceCount) {",
                    "        object.__sphere3DExtension.sphere3DRenderer = new gdjs.__sphere3DExtension.Sphere3DRenderer(",
                    "            object,  radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength, instanceCount, offsetX, offsetY, offsetZ, maxYCount, maxZCount",
                    "        );",
                    "    }",
                    "} catch (error) {",
                    "    console.log(\"An error occurred:\", error.message);",
                    "}",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "InstancedMeshRelease::InstancedMeshSphere",
              "type": "object"
            }
          ],
          "objectGroups": []
        }
      ],
      "propertyDescriptors": [
        {
          "value": "100",
          "type": "Number",
          "label": "Radius",
          "description": "Radius",
          "group": "Size",
          "extraInformation": [],
          "name": "radiusMy"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Number of sphere instances to create",
          "description": "Number of sphere instances to create",
          "group": "",
          "extraInformation": [],
          "name": "countMy"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "X space between instances",
          "description": "X space between instances",
          "group": "Offset",
          "extraInformation": [],
          "name": "offsetX"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Y space between instances",
          "description": "Y space between instances",
          "group": "Offset",
          "extraInformation": [],
          "name": "offsetY"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Z space between instances",
          "description": "Z space between instances",
          "group": "Offset",
          "extraInformation": [],
          "name": "offsetZ"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Horizontal size grid",
          "description": "Horizontal size grid",
          "group": "Grid",
          "extraInformation": [],
          "name": "horizontalMax"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Vertical size grid",
          "description": "Vertical size grid",
          "group": "Grid",
          "extraInformation": [],
          "name": "verticalMax"
        },
        {
          "value": "16",
          "type": "Number",
          "label": "Width segments",
          "description": "Width segments",
          "group": "Segments",
          "extraInformation": [],
          "name": "widthSegments"
        },
        {
          "value": "16",
          "type": "Number",
          "label": "Height segments",
          "description": "Height segments",
          "group": "Segments",
          "extraInformation": [],
          "name": "heightSegments"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Phi start",
          "description": "Phi start",
          "group": "Segments",
          "extraInformation": [],
          "name": "phiStart"
        },
        {
          "value": "7",
          "type": "Number",
          "label": "Phi length",
          "description": "Phi length",
          "group": "Segments",
          "extraInformation": [],
          "name": "phiLength"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Theta start",
          "description": "Theta start",
          "group": "Segments",
          "extraInformation": [],
          "name": "thetaStart"
        },
        {
          "value": "7",
          "type": "Number",
          "label": "Theta length",
          "description": "Theta length",
          "group": "Segments",
          "extraInformation": [],
          "name": "thetaLength"
        }
      ],
      "objects": [],
      "objectsFolderStructure": {
        "folderName": "__ROOT"
      }
    },
    {
      "defaultName": "Instanced_mesh_torus",
      "description": "Instanced mesh torus",
      "fullName": "Instanced mesh torus",
      "is3D": true,
      "name": "InstancedMeshTorus",
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onCreated",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_type",
                    "=",
                    "\"torus\""
                  ]
                },
                {
                  "type": {
                    "value": "InstancedMeshRelease::DefineHelperClasses"
                  },
                  "parameters": [
                    "",
                    ""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_radius",
                    "=",
                    "radiusMy"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_tube",
                    "=",
                    "tube"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_radialSegments",
                    "=",
                    "radialSegments"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_tubularSegments",
                    "=",
                    "tubularSegments"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_arc",
                    "=",
                    "arc"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_instanceCount",
                    "=",
                    "countMy"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_offsetX",
                    "=",
                    "offsetX"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_offsetY",
                    "=",
                    "offsetY"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_offsetZ",
                    "=",
                    "offsetZ"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_horizontalMax",
                    "=",
                    "horizontalMax"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_verticalMax",
                    "=",
                    "verticalMax"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "if (!object.__torus3DExtension) {",
                    "    object.__torus3DExtension = {};",
                    "}",
                    "",
                    "try {",
                    "    const variables = runtimeScene.getGame().getVariables();",
                    "    const radius = variables.get(\"_customThreeObject_radius\").getAsNumber() ;",
                    "    const tube = variables.get(\"_customThreeObject_tube\").getAsNumber();",
                    "    const radialSegments = variables.get(\"_customThreeObject_radialSegments\").getAsNumber();",
                    "    const tubularSegments = variables.get(\"_customThreeObject_tubularSegments\").getAsNumber();",
                    "    const arc = variables.get(\"_customThreeObject_arc\").getAsNumber();",
                    "    const instanceCount = variables.get(\"_customThreeObject_instanceCount\").getAsNumber();",
                    "    const offsetX = variables.get(\"_customThreeObject_offsetX\").getAsNumber();",
                    "    const offsetY = variables.get(\"_customThreeObject_offsetY\").getAsNumber();",
                    "    const offsetZ = variables.get(\"_customThreeObject_offsetZ\").getAsNumber();",
                    "    const maxYCount = variables.get(\"_customThreeObject_horizontalMax\").getAsNumber() || 1;",
                    "    const maxZCount = variables.get(\"_customThreeObject_verticalMax\").getAsNumber() || 1;",
                    "",
                    "    if (!object.__torus3DExtension.torus3DRenderer || object.__torus3DExtension.torus3DRenderer.instancedMesh.count !== instanceCount) {",
                    "        object.__torus3DExtension.torus3DRenderer = new gdjs.__torus3DExtension.Torus3DRenderer(",
                    "            object,  radius, tube, radialSegments, tubularSegments, arc, instanceCount, offsetX, offsetY, offsetZ, maxYCount, maxZCount",
                    "        );",
                    "    }",
                    "} catch (error) {",
                    "    console.log(\"An error occurred:\", error.message);",
                    "}",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "InstancedMeshRelease::InstancedMeshTorus",
              "type": "object"
            }
          ],
          "objectGroups": []
        }
      ],
      "propertyDescriptors": [
        {
          "value": "100",
          "type": "Number",
          "label": "Radius",
          "description": "Radius",
          "group": "Size",
          "extraInformation": [],
          "name": "radiusMy"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Number of torus instances to create",
          "description": "Number of torus instances to create",
          "group": "",
          "extraInformation": [],
          "name": "countMy"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "X space between instances",
          "description": "X space between instances",
          "group": "Offset",
          "extraInformation": [],
          "name": "offsetX"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Y space between instances",
          "description": "Y space between instances",
          "group": "Offset",
          "extraInformation": [],
          "name": "offsetY"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Z space between instances",
          "description": "Z space between instances",
          "group": "Offset",
          "extraInformation": [],
          "name": "offsetZ"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Horizontal size grid",
          "description": "Horizontal size grid",
          "group": "Grid",
          "extraInformation": [],
          "name": "horizontalMax"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Vertical size grid",
          "description": "Vertical size grid",
          "group": "Grid",
          "extraInformation": [],
          "name": "verticalMax"
        },
        {
          "value": "12",
          "type": "Number",
          "label": "Radial segments",
          "description": "Radial segments",
          "group": "Segments",
          "extraInformation": [],
          "name": "radialSegments"
        },
        {
          "value": "40",
          "type": "Number",
          "label": "Tubula segments",
          "description": "Tubula segments",
          "group": "Segments",
          "extraInformation": [],
          "name": "tubularSegments"
        },
        {
          "value": "30",
          "type": "Number",
          "label": "Tube",
          "description": "Tube",
          "group": "Segments",
          "extraInformation": [],
          "name": "tube"
        },
        {
          "value": "7",
          "type": "Number",
          "label": "Arc",
          "description": "Arc",
          "group": "Segments",
          "extraInformation": [],
          "name": "arc"
        }
      ],
      "objects": [],
      "objectsFolderStructure": {
        "folderName": "__ROOT"
      }
    },
    {
      "defaultName": "Instanced_mesh_tube",
      "description": "Instanced mesh tube",
      "fullName": "Instanced mesh tube",
      "is3D": true,
      "name": "InstancedMeshTube",
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onCreated",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_type",
                    "=",
                    "\"tube\""
                  ]
                },
                {
                  "type": {
                    "value": "InstancedMeshRelease::DefineHelperClasses"
                  },
                  "parameters": [
                    "",
                    ""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_radius",
                    "=",
                    "radiusMy"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_radialSegments",
                    "=",
                    "radialSegments"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_tubularSegments",
                    "=",
                    "tubularSegments"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_closed",
                    "=",
                    "closed"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_instanceCount",
                    "=",
                    "countMy"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_offsetX",
                    "=",
                    "offsetX"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_offsetY",
                    "=",
                    "offsetY"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_offsetZ",
                    "=",
                    "offsetZ"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_horizontalMax",
                    "=",
                    "horizontalMax"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_verticalMax",
                    "=",
                    "verticalMax"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_segmentLength",
                    "=",
                    "segmentLength"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_numSegments",
                    "=",
                    "numSegments"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_horizontalAngles",
                    "=",
                    "horizontalAngles"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_verticalAngles",
                    "=",
                    "verticalAngles"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_tubeThickness",
                    "=",
                    "tubeThickness"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const object = objects[0];",
                    "if (!object.__tube3DExtension) {",
                    "    object.__tube3DExtension = {};",
                    "}",
                    "",
                    "try {",
                    "    const variables = runtimeScene.getGame().getVariables();",
                    "    const segmentLengths = variables.get(\"_customThreeObject_segmentLength\").getAsString() ;",
                    "    const segmentCount = variables.get(\"_customThreeObject_numSegments\").getAsNumber() ;",
                    "    const horizontalAngles = variables.get(\"_customThreeObject_horizontalAngles\").getAsString() ;",
                    "    const verticalAngles = variables.get(\"_customThreeObject_verticalAngles\").getAsString() ;",
                    "    const radius = variables.get(\"_customThreeObject_radius\").getAsNumber() ;",
                    "    const radiusSegments = variables.get(\"_customThreeObject_radialSegments\").getAsNumber();",
                    "    const tubularSegments = variables.get(\"_customThreeObject_tubularSegments\").getAsNumber();",
                    "    const tubeThickness = variables.get(\"_customThreeObject_tubeThickness\").getAsNumber();",
                    "    const closed = false;",
                    "    const instanceCount = variables.get(\"_customThreeObject_instanceCount\").getAsNumber();",
                    "    const offsetX = variables.get(\"_customThreeObject_offsetX\").getAsNumber();",
                    "    const offsetY = variables.get(\"_customThreeObject_offsetY\").getAsNumber();",
                    "    const offsetZ = variables.get(\"_customThreeObject_offsetZ\").getAsNumber();",
                    "",
                    "    if (!object.__tube3DExtension.tube3DRenderer || object.__tube3DExtension.tube3DRenderer.instancedMesh.count !== instanceCount) {",
                    "        object.__tube3DExtension.tube3DRenderer = new gdjs.__tube3DExtension.Tube3DRenderer(",
                    "            object,  tubularSegments, radius, radiusSegments, closed, instanceCount, offsetX, offsetY, offsetZ, segmentLengths, horizontalAngles, verticalAngles, segmentCount, tubeThickness",
                    "        );",
                    "    }",
                    "} catch (error) {",
                    "    console.log(\"An error occurred:\", error.message);",
                    "}",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "InstancedMeshRelease::InstancedMeshTube",
              "type": "object"
            }
          ],
          "objectGroups": []
        }
      ],
      "propertyDescriptors": [
        {
          "value": "200",
          "type": "Number",
          "label": "Outer radius",
          "description": "Outer radius",
          "group": "Size",
          "extraInformation": [],
          "name": "radiusMy"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Number of tube instances to create",
          "description": "Number of tube instances to create",
          "group": "",
          "extraInformation": [],
          "name": "countMy"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "X space between instances",
          "description": "X space between instances",
          "group": "Offset",
          "extraInformation": [],
          "name": "offsetX"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Y space between instances",
          "description": "Y space between instances",
          "group": "Offset",
          "extraInformation": [],
          "name": "offsetY"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Z space between instances",
          "description": "Z space between instances",
          "group": "Offset",
          "extraInformation": [],
          "name": "offsetZ"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Horizontal size grid",
          "description": "Horizontal size grid",
          "group": "Grid",
          "extraInformation": [],
          "name": "horizontalMax"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Vertical size grid",
          "description": "Vertical size grid",
          "group": "Grid",
          "extraInformation": [],
          "name": "verticalMax"
        },
        {
          "value": "20",
          "type": "Number",
          "label": "Radial segments",
          "description": "Radial segments",
          "group": "Segments",
          "extraInformation": [],
          "name": "radialSegments"
        },
        {
          "value": "40",
          "type": "Number",
          "label": "Tubular segments",
          "description": "Tubular segments",
          "group": "Segments",
          "extraInformation": [],
          "name": "tubularSegments"
        },
        {
          "value": "500",
          "type": "Number",
          "label": "Segment length (array possible: 500, 450, 900, 250, 450...)",
          "description": "Segment length (array possible: 500, 450, 900, 250, 450...)",
          "group": "Curve",
          "extraInformation": [],
          "name": "segmentLength"
        },
        {
          "value": "3",
          "type": "Number",
          "label": "Number of segments",
          "description": "Number of segments",
          "group": "Curve",
          "extraInformation": [],
          "name": "numSegments"
        },
        {
          "value": "",
          "type": "Boolean",
          "label": "Closed",
          "description": "Closed",
          "group": "",
          "extraInformation": [],
          "name": "closed"
        },
        {
          "value": "180",
          "type": "Number",
          "label": "Inner radius",
          "description": "Inner radius",
          "group": "Size",
          "extraInformation": [],
          "name": "tubeThickness"
        },
        {
          "value": "25",
          "type": "String",
          "label": "Vertical angles (array possible: 15, 45, 90, 25, 45...)",
          "description": "Vertical angles (array possible: 15, 45, 90, 25, 45...)",
          "group": "Curve",
          "extraInformation": [],
          "name": "verticalAngles"
        },
        {
          "value": "25",
          "type": "String",
          "label": "Horizontal angles (array possible: 15, 45, 90, 25, 45...)",
          "description": "Horizontal angles (array possible: 15, 45, 90, 25, 45...)",
          "group": "Curve",
          "extraInformation": [],
          "name": "horizontalAngles"
        }
      ],
      "objects": [],
      "objectsFolderStructure": {
        "folderName": "__ROOT"
      }
    },
    {
      "defaultName": "Instanced_mesh_original",
      "description": "Instanced mesh original",
      "fullName": "Instanced mesh original",
      "is3D": true,
      "name": "InstancedMeshOriginal",
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onCreated",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_type",
                    "=",
                    "\"original_geometry\""
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_path",
                    "=",
                    "pathGLB"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_width",
                    "=",
                    "scaleX"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_height",
                    "=",
                    "scaleY"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_depth",
                    "=",
                    "scaleZ"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_instanceCount",
                    "=",
                    "instanceCount"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_offsetX",
                    "=",
                    "offsetX"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_offsetY",
                    "=",
                    "offsetY"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_offsetZ",
                    "=",
                    "offsetZ"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_horizontalMax",
                    "=",
                    "maxY"
                  ]
                },
                {
                  "type": {
                    "value": "ModVarGlobalTxt"
                  },
                  "parameters": [
                    "_customThreeObject_verticalMax",
                    "=",
                    "maxZ"
                  ]
                },
                {
                  "type": {
                    "value": "InstancedMeshRelease::DefineHelperClasses"
                  },
                  "parameters": [
                    "",
                    ""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "/** @type {gdjs.CustomRuntimeObject} */",
                "const object = objects[0];",
                "const objectName = objects[0].getName()",
                "if (!object.__model3DExtension){",
                "    object.__model3DExtension = {};",
                "}  ",
                "",
                "const variables = runtimeScene.getGame().getVariables();",
                "const customName = objectName;",
                "const pathGLB = variables.get(\"_customThreeObject_path\").getAsString();",
                "const instanceCount = variables.get(\"_customThreeObject_instanceCount\").getAsNumber();",
                "const scaleX = variables.get(\"_customThreeObject_width\").getAsNumber();",
                "const scaleY = variables.get(\"_customThreeObject_height\").getAsNumber();",
                "const scaleZ = variables.get(\"_customThreeObject_depth\").getAsNumber();",
                "const offsetX = variables.get(\"_customThreeObject_offsetX\").getAsNumber();",
                "const offsetY = variables.get(\"_customThreeObject_offsetY\").getAsNumber();",
                "const offsetZ = variables.get(\"_customThreeObject_offsetZ\").getAsNumber();",
                "const maxY = variables.get(\"_customThreeObject_horizontalMax\").getAsNumber();",
                "const maxZ = variables.get(\"_customThreeObject_verticalMax\").getAsNumber();",
                "",
                "",
                "",
                "object.__model3DExtension.model3DRenderer = new gdjs.__model3DExtension.Model3DRenderer(object, customName, pathGLB, scaleX, scaleY, scaleZ, instanceCount, offsetX, offsetY, offsetZ, maxY, maxZ);",
                "        ",
                "",
                "    ",
                "",
                "",
                "",
                ""
              ],
              "parameterObjects": "Object",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Object",
              "name": "Object",
              "supplementaryInformation": "InstancedMeshRelease::InstancedMeshOriginal",
              "type": "object"
            }
          ],
          "objectGroups": [
            {
              "name": "GroupInstancedMesh",
              "objects": [
                {
                  "name": "Object"
                }
              ]
            }
          ]
        }
      ],
      "propertyDescriptors": [
        {
          "value": "model.glb",
          "type": "String",
          "label": "GLB model name (example: \"model_name.glb\")",
          "description": "GLB model name (example: \"model_name.glb\")",
          "group": "Name",
          "extraInformation": [],
          "name": "pathGLB"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Scale X",
          "description": "Scale X",
          "group": "Scale",
          "extraInformation": [],
          "name": "scaleX"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Scale Y",
          "description": "Scale Y",
          "group": "Scale",
          "extraInformation": [],
          "name": "scaleY"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Scale Z",
          "description": "Scale Z",
          "group": "Scale",
          "extraInformation": [],
          "name": "scaleZ"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Number of original instances to create",
          "description": "Number of original instances to create",
          "group": "",
          "extraInformation": [],
          "name": "instanceCount"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Offset X",
          "description": "Offset X",
          "group": "Offset",
          "extraInformation": [],
          "name": "offsetX"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Offset Y",
          "description": "Offset Y",
          "group": "Offset",
          "extraInformation": [],
          "name": "offsetY"
        },
        {
          "value": "0",
          "type": "Number",
          "label": "Offset Z",
          "description": "Offset Z",
          "group": "Offset",
          "extraInformation": [],
          "name": "offsetZ"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Horizontal size grid",
          "description": "Horizontal size grid",
          "group": "Grid",
          "extraInformation": [],
          "name": "maxY"
        },
        {
          "value": "1",
          "type": "Number",
          "label": "Vertical size grid",
          "description": "Vertical size grid",
          "group": "Grid",
          "extraInformation": [],
          "name": "maxZ"
        }
      ],
      "objects": [],
      "objectsFolderStructure": {
        "folderName": "__ROOT"
      }
    }
  ]
}